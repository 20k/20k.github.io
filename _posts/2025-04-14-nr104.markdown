---
layout: post
title:  "Numerical Relativity 104: How do you build a neutron star, and what even is it?"
date:   2026-02-02 12:33:23 +0000
categories: C++
---

Today's job is very simple, conceptually. We're going to dig into what it means for something to be a neutron star - how you represent these in general relativity, and all the necessary steps you'll need to solve along the way to successfully bring one to life in a full general relativistic simulation

You should know before we get into this, that it is going to be a *huge* pain, so saddle up

# Background

## So, what even is a neutron star anyway?

Fundamentally, a neutron star is a star that is so dense, that it is energetically favourable for the protons and neutrons that make it up to combine to form neutrons. As a result, they are essentially made up largely of pure neutrons, under incredible pressure

If this sounds sufficiently exotic that it might pose some fundamental physics problems - then you'd be absolutely correct. Nobody is really *super* duper sure exactly what the deal with the physics inside a neutron star is. There's a few problems:

1. You can't make neutronium in a lab to measure its properties, because you'd find yourself immediately dead
2. There's no way to make general relativity and quantum physics get along nicely at these scales
3. General relativity does not provide a polite solution for a spinning fluid, which means that many of the approximate models that exist are very approximate

This means that a fully predictive approach with a single answer is out of the window, and we'll have to use some kind of model. This might seem a bit of a problem, but luckily, its not as horrendous as it might seem

We won't be exploring magnetic fields in this article, but you should know they can play an important role in the physics

## Bodies in hydrostatic equilibrium

All stars (other than black holes) are in something known as hydrostatic equilibrium. This means that the force of gravity trying to squish them, is balanced by some internal force pushing against gravity - which can be generated by a variety of means. This is generally considered as a pressure, which we'll call $P$. If $P$ > gravity, a star would expand, and if $P$ < gravity, a star would shrink, until we reached a new equilibrium as the pressure changes

We don't get to pick this pressure completely freely however. There are two other variables we need to complete our description of a star:

1. The density of matter at the centre of the star $p_c$
2. An *equation of state*, which relates the pressure $P$, to the density of matter, within the star

It might seem surprising, but with this all together, we're able to fully describe any **non spinning** body in hydrostatic equilibrium. This gives us:

1. The radius $r$ of the star
2. The total (rest) mass of the star $M_0$[^restmass]
3. The distribution of mass (and pressure/energy) within the star

[^restmass]: You could think of this as a count of the number of particles that make up the star if you're thinking about frames of reference or simultaneity with measurements

You might notice that in real life, we often have a real measurement of the total mass of the star $M_0$, calculated via alternate means. If this is true, this allows us to constrain the central density to a small number of values

In newtonian dynamics, the equations governing hydrostatic equilibrium are sufficiently simple that I wouldn't be writing this article. You've probably noticed roughly about now that this article is really very long, so clearly something's about to go terribly wrong. From here on out I'm exiting explanatory background mode, and we're now going to dig into it

# Initial conditions

So, lets lay out the game plan for the sequence of steps here

1. First we'll be constructing a non spinning, isolated neutron star. This will be modelled as a self gravitating fluid in hydrostatic equilibrium. We'll be solving an equation known as the TOV equation (Tolman–Oppenheimer–Volkoff), which will fully describe that static star. This is actually a set of partial differential equations, and a good reference for what we're doing is over [here](https://einsteintoolkit.org/thornguide/EinsteinInitialData/TOVSolver/documentation.html#x1-2004r4)
2. Then, we must re-describe that same star as a spinning, moving star. This involves integrating another series of equations, which will be derived from [this](https://arxiv.org/pdf/1606.04881) paper. Its notable that while a real spinning star would be oblate, not modelling this is a deliberate approximation
3. Once we have our spinning, moving body, we then have to make it physical by solving for a correction, to make it satisfy physical constraints. If you remember the black hole initial conditions, this is the same process
4. After all of this, we then need to construct our final hydrodynamic variables - like velocity, density, and energy density

Each of these steps is extremely non trivial, and will be presented in detail. If you're wondering why we don't simply directly construct a spinning neutron star through some kind of spinning TOV, its because the equation simply doesn't exist

## Tolman-Oppenheimer-Volkoff (TOV): A non spinning relativistic body in hydrostatic equilibrium

The equation that governs a relativistic, non spinning, spherically symmetric body in hydrostatic equilibrium is called the TOV equation. This is a set of two coupled partial differential equations, which we must solve simultaneously

Wikipedia lists a more complex[^postnewtonian] form of the equations, so [here's (6-7)](https://einsteintoolkit.org/thornguide/EinsteinInitialData/TOVSolver/documentation.html) a nicer form (in units of $c=G=1$, schwarzschild coordinates):

[^postnewtonian]: They're structured in a form to compare with newtonian theory, as a post newtonian analysis. They are however not super useful

$$\begin{align}
\frac{dm}{dr} &= 4 \pi r^2 \mu\\
\frac{dP}{dr} &= -(\mu + P)\frac{m + 4 \pi r^3 P}{r(r-2m)}
\end{align}$$

|Symbol|Meaning|
|-|-|
|$r$|The radius, which parameterises the integration|
|$m$|The mass at a radius of less than $r$. Corresponds to the ADM mass (todo: wait, does it?)|
|$P$|Pressure at $r$|
|$\mu$| Total specific energy density at $r$. This isn't the energy density integrated, 'total' refers to a combination of different energies - but at a specific point|
|$\epsilon$| Specific internal energy density, ar $r$|
|$\rho_0$ | Rest mass density at $r$|
|$P = F(\rho_0)$ | Equation of state|

As mentioned previously, we need an equation of state to tie together $\mu$, $\rho_0$ and $P$, which is used implicitly. Here's how to actually calculate everything, and how it all relates:[^relates]

[^relates]: This is one of the areas of the literature where the notation is unfortunately very muddled, so I'm going to try very hard to be as consistent as humanly possible.

|Symbol|Name|Si Units|Geometric Units|How you should get this variable|
|-|-|-|-|-|
|$r$|Radius (schwarzschild coordinates)|$\mathrm{m}$|$\mathrm{m}$| Parameterises the integration |
|$m$|Mass|$\mathrm{kg}$|$\mathrm{m}$| Integration variable |
|$P$|Pressure|$\mathrm{kg}\;\mathrm{m}^{-1} \; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$| Integration variable |
|$\mu$|Total Specific Energy Density|$\mathrm{kg}\; \mathrm{m}^{-1}\; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$\mu = \rho_0 (1 + \epsilon)$|
|$\rho_0$|Rest Mass Density|$\mathrm{kg}\; \mathrm{m}^{-3}$|$\mathrm{m}^{-2}$|Invert EoS||

We'll also be getting $\epsilon$ by interrogating our equation of state. Here's some additional equations that are useful:

|Equation| Notes |
|-|-|
|$h = 1 + \epsilon + \frac{P}{\rho_0}$| Specific enthalpy |
|$\rho_0h = \mu + P$| |

In general, you'll need to numerically invert the equation of state for some arbitrary equation

### Equation of state (EOS)

The simplest equation of state is to model our body as something called a polytrope. This assigns simple relations between our currently unconstrained variables:

1. $P = (\Gamma - 1) \rho_0 \epsilon$ - sometimes called the Gamma law equation of state, for a perfect fluid
2. $P = K \rho_0^\Gamma$ - the polytropic equation of state

The perfect fluid equation of state is often assumed implicitly. Its worth noting that the polytropic equation of state is actually a *subset* of the perfect fluid equation of state for an adiabatic process, which means that this is actually only one state model overall. In general, basic hydrodynamic simulations tend to construct stars with a polytropic equation of state, and then evolve them with the perfect fluid equation of state

With these, we can calculate our variables a bit more directly:

|Symbol|Name|Si Units|Geometric Units|Derivation from $P$|Derivation from $\rho_0$|
|-|-|-|-|-|-|
|$P$|Pressure|$\mathrm{kg}\;\mathrm{m}^{-1} \; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$P$|$K \rho_0^\Gamma$|
|$\mu$|Total Energy Density|$\mathrm{kg}\; \mathrm{m}^{-1}\; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$(\frac{P}{K})^{1/\Gamma} + \frac{P}{\Gamma-1}$|$\rho_0 + K \frac{\rho_0^\Gamma}{\Gamma-1}$|
|$\rho_0$|Rest Mass Density|$\mathrm{kg}\; \mathrm{m}^{-3}$|$\mathrm{m}^{-2}$|$(\frac{P}{K})^{1/\Gamma}$|$\rho_0$|
|$K$|Polytropic Constant (informal)|$\mathrm{kg}^{1-\Gamma} \; \mathrm{m}^{3\Gamma-1}\;\mathrm{s}^{-2}$|$\mathrm{m}^{2\Gamma-2}$|||
|$\Gamma$| Polytropic index, often $2$| Dimensionless constant | Dimensionless constant |||

This in general is the 'toy' equation of state, although it is extremely widely used in these simulations. You may see papers also using $\Gamma = 1.75$. In this article, while I'll be going over specific test cases later, please assume that $\Gamma = 2$ and $K = 123.641$ in units of $c=G=M_\odot=1$

### Less toy equations of state

A more advanced method of modelling a neutron star is to construct a piecewise representation of its equation of state: Essentially, you piece together a bunch of polytropic parts (with different $K$ and $\Gamma$ values) based on some real physics, and ensure some kind of continuity at the boundary between them:

https://www.as.utexas.edu/astronomy/education/spring13/bromm/secure/TOC_Supplement.pdf

$$
\begin{equation}
P =
\begin{cases}
K_0 \rho_0^{\Gamma_0}, & \mathrm{\rho_0 < \rho_0^0} \\
K_1 \rho_0^{\Gamma_1}, & \mathrm{\rho_0^0 < \rho_0 < \rho_0^1} \\
K_n \rho_0^{\Gamma_n}, & \mathrm{\rho_0^{n-1} < \rho_0 < \rho_0^n} \\
\end{cases}
\end{equation}
$$

Using a piecewise perfect fluid equation of state, we can get the relations for the other variables:

$$
\begin{align}
\epsilon &= 1 + a_i + \frac{K_i}{\Gamma_i - 1} \rho_0^{\Gamma_i - 1}\\
a_0 &= 0\\
a_i &= a_{i-1} + \frac{K_{i-1}}{\Gamma_{i-1} - 1} (\rho_0^i)^{\Gamma_{i-1} - 1} - \frac{K_i}{\Gamma_i - 1} (\rho_0^i)^{\Gamma_i - 1}
\end{align}
$$

I've converted these equations into our notation, as you should be aware that $\epsilon$ has a different construction in the referenced papers. Note that the $i$ and $n$ in $(p_0^i)$ is an index due to an unfortunate notational clash, and it gets raised to the power of $\Gamma_{i-1} - 1$

Please see [here (7)](https://arxiv.org/pdf/0812.2163) and [here (25)](https://www.as.utexas.edu/astronomy/education/spring13/bromm/secure/TOC_Supplement.pdf) for more details

## Solving the TOV equations

It is common to solve these equations in units of $c=G=M_\odot=1$, where $M_\odot$ is the mass of the sun. This is why I've provided all the units up above, and we're going go through [converting](https://www.seas.upenn.edu/~amyers/NaturalUnits.pdf) from SI units, to geometric units ($c=G=1$), to that new unit system ($c=G=M_\odot=1$). In general, you need to redefine mass to avoid the numerics blowing up. While I'll be solving this with the 'toy' $\Gamma=2$ equation of state, I'm presenting a method that makes absolutely no assumptions

### Unit conversions

The procedure for doing the unit conversion is as follows:

1. Given an quantity in SI units $\mathrm{kg}^\alpha \mathrm{m}^\beta \mathrm{s}^\gamma$, convert it to geometric units by dividing by $G^{-\alpha} c^{2 \alpha - \gamma}$. This gives you a new geometrised unit, $\mathrm{m}^{\alpha + \beta + \gamma}$
2. Convert the mass of the sun, $1.988416 * 10^{30} \mathrm{kg}$, into meters, which is ~$1476.6196 \mathrm{m}$
3. Divide your quantity in units of $\mathrm{m}^n$ (eg $\mathrm{m}^2$) by $1476.6196^n$

I'll be showing you the code for how to do this. One thing to note is that $K$ is frequently given in geometric units instead of physical units, so I'll flag up when the units are wonky

### Initial conditions

Once you've got everything in the correct units, we can start solving. Firstly, you might notice that the equations are singular at $r=0$. We're going to instead start at $r=r_{min}=10^{-6}$

This is the set of initial values to use at $r_{min}$:

|Variable|Value|
|-|-|
|$M$| $\frac{4}{3} \pi r_{min}^3 \mu\;$ (the integral of $\frac{dm}{dr}$, with $\mu$ held constant) |
|$P$| $K \rho_c^\Gamma$ |
|$r$| $r_{min}$ |

### Integration

With the initial conditions done, you can integrate the equations. This is done by spotting that these are simple first order in 'time' (where $dt=dr$) systems, and can be solved with euler integration[^unstable] very straightforwardly. The termination condition is when $P < 0$, or you can use a small cutoff. I also do a few sanity checks, to make sure we haven't accidentally constructed a black hole, or something with a suspiciously low mass or radius

That's it!

[^unstable]: I've seen multiple reports in the literature that these equations are very stiff and hard to solve, but have not found this in practice

## Implementation

These equations are extremely fast to solve, so there's nothing too fancy going on here

### Unit conversioins

Here's how all the unit conversions work:

```c++
///https://www.seas.upenn.edu/~amyers/NaturalUnits.pdf
//https://nssdc.gsfc.nasa.gov/planetary/factsheet/sunfact.html
double geometric_to_msol(double meters, double m_exponent)
{
    double m_to_kg = 1.3466 * pow(10., 27.);
    double msol_kg = 1.988416 * pow(10., 30.);
    double msol_meters = msol_kg / m_to_kg;

    return meters / pow(msol_meters, m_exponent);
}

double msol_to_geometric(double distance, double m_exponent)
{
    return geometric_to_msol(distance, -m_exponent);
}

double si_to_geometric(double quantity, double kg_exponent, double s_exponent)
{
    double G = 6.6743015 * pow(10., -11.);
    double C = 299792458;

    double factor = std::pow(G, -kg_exponent) * std::pow(C, 2 * kg_exponent - s_exponent);

    return quantity / factor;
}

double geometric_to_si(double quantity, double kg_exponent, double s_exponent)
{
    return si_to_geometric(quantity, -kg_exponent, -s_exponent);
}
```

### Equation of State

For flexibility, I define a very general class of equation of state:

```c++
struct base
{
    virtual double mu_to_p0(double mu) const{
        return invert(
        [&](double y){
            return p0_to_mu(y);
        }, mu);
    };

    virtual double p0_to_mu(double p0) const = 0;

    virtual double mu_to_P(double mu) const{return p0_to_P(mu_to_p0(mu));};
    virtual double P_to_mu(double P) const{return p0_to_mu(P_to_p0(P));};

    virtual double P_to_p0(double P) const{
        return invert(
        [&](double y){
            return p0_to_P(y);
        }, P);
    };

    virtual double p0_to_P(double p0) const = 0;

    virtual ~base(){}
};
```

In theory, we only have to actually define two members here to get everything we'll need: `p0_to_P`, and `p0_to_mu`. Later down the line, it'll become a bit more obvious when we want to do this for performance reasons

#### Polytropic equation of state

This is simple enough:

```c++
double tov::eos::polytrope::p0_to_mu(double p0) const
{
    double P = p0_to_P(p0);

    return p0 + P / (Gamma - 1);
}

double tov::eos::polytrope::P_to_p0(double P) const
{
    return pow(P/K, 1/Gamma);
}

double tov::eos::polytrope::p0_to_P(double p0) const
{
    return K * pow(p0, Gamma);
}
```

The implementation of `P_to_p0` is useful later, when we perform a bruteforce search of the ADM space

#### Numerical inversions of the equation of state

Being able to numerically invert a generic function here is going to prove to be quite useful, so lets examine a basic function inverter:

```c++
template<typename T>
double invert(T&& func, double y, double lower = 0, double upper = 1, bool should_search = true)
{
    if(should_search)
    {
        //assumes upper > lower
        while(func(upper) < y)
            upper *= 2;
    }

    for(int i=0; i < 10000; i++)
    {
        double lower_mu = func(lower);
        double upper_mu = func(upper);

        double next = 0.5 * lower + 0.5 * upper;

        if(std::fabs(upper - lower) <= 1e-14)
            return next;

        //hit the limits of precision
        if(next == upper || next == lower)
            return next;

        double x = func(next);

        if(upper_mu >= lower_mu)
        {
            if(x >= y)
                upper = next;
            ///x < y
            else
                lower = next;
        }
        else
        {
            if(x >= y)
                lower = next;
            else
                upper = next;
        }
    }

    assert(false);
};
```

This performs a basic binary search through our function space, until some very low error tolerance is reached. Additionally, for many functions we won't actually know what our upper bound is, so this guessess it by doubling. That'll only work for functions which are monotonically *increasing*, which is true for all our EoS functions

### INtegration

Initialising the integration state in units of $c=G=M\odot$ is straightforward:

```c++
struct integration_state
{
    double m = 0;
    double p = 0;
};

integration_state make_integration_state(double central_rest_mass_density, double rmin, const eos::base& param)
{
    double mu_c = param.p0_to_mu(central_rest_mass_density);

    double m = (4./3.) * pi * mu_c * std::pow(rmin, 3.);

    integration_state out;
    out.p = param.mu_to_P(mu_c);
    out.m = m;
    return out;
}
```

Or, if you want to use SI units for the central density:

```c++
//p0 in si units
integration_state make_integration_state_si(double central_rest_mass_density, double rmin, const parameters& param)
{
    //kg/m^3 -> m/m^3 -> 1/m^2
    double p0_geom = si_to_geometric(central_rest_mass_density, 1, 0);
    //m^-2 -> msol^-2
    double p0_msol = geometric_to_msol(p0_geom, -2);

    return make_integration_state(p0_msol, rmin, param);
}
```

The actual integration itself is then easy:

```c++

struct integration_dr
{
    double dm = 0;
    double dp = 0;
};

//implements the actual tov equations
std::optional<integration_dr> get_derivs(double r, const tov::integration_state& st, const tov::eos::base& param)
{
    std::optional<integration_dr> out;

    double mu = param.P_to_mu(st.p);

    double p = st.p;
    double m = st.m;

    //black hole + numerical error
    if(r <= 2 * m + 1e-12)
        return out;

    out.emplace();

    out->dm = 4 * pi * mu * std::pow(r, 2.);
    out->dp = -(mu + p) * (m + 4 * pi * r*r*r * p) / (r * (r - 2 * m));
    return out;
}

struct integration_solution
{
    double M_msol = 0;
    double R_msol = 0;

    std::vector<double> energy_density;
    std::vector<double> pressure;
    std::vector<double> cumulative_mass;
    std::vector<double> radius; //in schwarzschild coordinates, in units of c=G=mSol = 1

    double M_geom() const;
    double R_geom() const;
};

///units are c=g=msol=1
std::optional<tov::integration_solution> tov::solve_tov(const integration_state& start,  const tov::eos::base& param, double min_radius, double min_pressure)
{
    integration_state st = start;

    double current_r = min_radius;
    double dr = 1. / 1024.;

    integration_solution sol;

    double last_r = 0;
    double last_m = 0;

    while(1)
    {
        //save current integration state
        sol.energy_density.push_back(param.P_to_mu(st.p));
        sol.pressure.push_back(st.p);
        sol.cumulative_mass.push_back(st.m);
        sol.radius.push_back(current_r);

        last_r = current_r;
        last_m = st.m;

        std::optional<integration_dr> data_opt = get_derivs(current_r, st, param);

        //oops, black hole!
        if(!data_opt.has_value())
            return std::nullopt;

        integration_dr& data = *data_opt;

        //euler integration
        st.m += data.dm * dr;
        st.p += data.dp * dr;
        current_r += dr;

        //something bad happened
        if(!std::isfinite(st.m) || !std::isfinite(st.p))
            return std::nullopt;

        //success!
        if(st.p <= min_pressure)
            break;
    }

    //sanity checks
    if(last_r <= min_radius * 100 || last_m < 0.0001f)
        return std::nullopt;

    sol.R_msol = last_r;
    sol.M_msol = last_m;

    return sol;
}
```

## Testing the implementation

We're going to define a few test cases:

| Case | $\rho_c$ | $K$ | $\Gamma$ | Expected $M$ | Expected $R$ | Notes |
|-|-|-|-|-|-|-|
| [C1](https://arxiv.org/pdf/1606.04881) (section VII) | $6.235\; 10^{17}\; \mathrm{kg}\;\mathrm{m}^{-3}$ |  $123.641 M_{\odot}^2$ where $c=G=1$[^waste] | $2$ |$1.543 M_\odot$ where ($c=G=1$) | $13.4 \mathrm{km}$ (?) | I'm unsure how they calculate their radius |
| [C2](https://einsteintoolkit.org/thornguide/EinsteinInitialData/TOVSolver/documentation.html) (see after interior) | $1.28 \; 10^{-3} \; \mathrm{m^{-2}}$ where ($c=G=M_{\odot} = 1$) | $100$ where ($c=G=M_{\odot} = 1)$ | 2 | $1.4 M_{\odot}$ where ($c=G=1$) | $14.15\; \mathrm{km}$ where $c=G=1$ | |

Note that a test case you might find over [here](https://colab.research.google.com/drive/1yMD2j3Y6TcsykCI59YWiW9WAMW-SPf12#scrollTo=00FWl5YzbSaB) uses too low of a value of $N$, and produces incorrect results. Its correct if you bump it up

[^waste]: If you'd like a peek behind the scenes on the development of these articles, it took me several days and 1k+ lines of code to figure out that this was the error that was preventing my integrator from working properly

Where the code for solving these looks like this:

```c++
void test_1()
{
    tov::eos::polytrope param(2, 123.641);
    double paper_p0 = 6.235 * pow(10., 17.);

    double rmin = 1e-6;

    tov::integration_state st = tov::make_integration_state_si(paper_p0, rmin, param);

    tov::integration_solution sol = tov::solve_tov(st, param, rmin, 0).value();

    std::cout << "Solved for " << sol.R_geom() / 1000. << "km " << sol.M_msol << " msols " << std::endl;
}
```

Here's where things get a little odd. We're able to match test case C2 (`14.1461km 1.40021 msols`), and we get the exact correct *mass* for C1, but the radius differs (`15.8102km 1.54315 msols`). We're likely in a different coordinate system at the moment (which is something we'll sort out later), but we'll still get a wrong answer even then after converting this. I suspect we're using a different measure of radius, but this paper does not list how it calculates the radius so its hard to really know what's going on here

Incidentally, the notebook test case we link gives `14.136399564110704km 1.400270088513766msols` when corrected, which is pretty close

All in all: this appears to work, but literature replication is a disaster as usual

## Solving for a specific ADM mass

You might notice, the ADM mass is not our free parameter - despite generally being what we want to specify - but instead the central density is

I think we both know deep down in our hearts that this section wasn't going to read "here's how to calculate the central density from the ADM mass", and that instead we'd be forced to bruteforce it. In general, I spent a while trying to find a good way to work out an a-priori range, but I gave up and I just bruteforce from $\mu=0$ to $\mu=0.1$

There's a teeny problem here though when looking for the initial conditions for a specific mass. Neutron star masses are not unique. You see, the graph of radius vs mass for increasing central densities looks like this:

![neutron](/assets/nr4_neutron.PNG)

This means that there might be multiple solutions for central density for a specific ADM mass, and for realistic neutron stars there are at least two. Which makes this problem much more annoying. Anyway, lets write a basic procedure for this:

```c++
//personally i liked the voyage home better
std::vector<double> tov::search_for_rest_mass(double mass, const tov::eos::base& param)
{
    double rmin = 1e-6;
    double min_density = 0.f;
    double max_density = 0.1f;

    std::vector<double> densities;
    std::vector<std::optional<double>> masses;

    int to_check = 200;
    densities.resize(to_check);
    masses.resize(to_check);

    for(int i=0; i < to_check; i++)
    {
        double frac = (double)i / to_check;

        double test_density = mix(min_density, max_density, frac);

        integration_state next_st = make_integration_state(test_density, rmin, param);
        std::optional<integration_solution> next_sol_opt = solve_tov(next_st, param, rmin, 0.);

        std::optional<double> mass;

        if(next_sol_opt)
            mass = next_sol_opt->M_msol;

        densities[i] = test_density;
        masses[i] = mass;
    }

    std::vector<double> out;

    for(int i=0; i < to_check - 1; i++)
    {
        if(!masses[i].has_value())
            continue;

        if(!masses[i+1].has_value())
            continue;

        double current = masses[i].value();
        double next = masses[i+1].value();

        double min_mass = std::min(current, next);
        double max_mass = std::max(current, next);

        if(mass >= min_mass && mass < max_mass)
        {
            auto get_mass = [&](double density_in){
                integration_state st = make_integration_state(density_in, rmin, param);
                integration_solution next_sol = solve_tov(st, param, rmin, 0.).value();

                return next_sol.M_msol;
            };

            double refined = tov::invert(get_mass, mass, densities[i], densities[i + 1], false);

            out.push_back(refined);
        }
    }

    return out;
}

```

This is a two step bruteforcer: First, I do a rough stepping over the parameter space, and then once I've found candidate central densities, I perform a high precision bruteforce via the invert function. This likely fails right at the vertical cusps of the neutron star graphs, but it works well in general

The lower density branch here (with larger radius) is the correct neutron star in our case if we're looking for test case C1, which we simply have to know a-priori

## Key takeaways from solving TOV

At the end of this process, we've gained the ability to fully describe the following variables of our neutron star: rest mass density $\rho_0$, energy density $\mu$, baryonic/rest mass $M$ (also called $M_0$), and pressure $P$. Keep this in mind as we carry on forwards. We've now solved the first step in our initial conditions procedure: constructing a spherically symmetric, static neutron star

Next up, we need to give it momentum and spin. This is where things get a bit complicated

# Bowen-York Type Initial Data for Binaries with Neutron Stars

The next step we need to do is take our matter distribution - spin it up somehow, and give it some momentum. To do this, we'll need to transplant it into the ADM formalism, and solve a bunch more equations

The actual paper we're going to be implementing today is [this](https://arxiv.org/pdf/1606.04881) one. Its going to be a step up in complexity compared to things we've solved previously together. One of the key things today in this article is that I'm going to present you with a simpler and fast procedure for implementing this paper, without losing any generality, as I've been able to skip some of the complexity. For consistency, we'll be keeping our existing notation, and below is the conversions we'll make

|Symbol|This article|Paper
|-|-|-|
|Total energy density|$\mu$|$\rho$|
|Pressure|$P$ or $p$|$p$|

I'm trying to stem the incredibly random notational divergence in the literature a bit to make things less crazy to follow, which is why I'm converting. We'll also be swapping from $P$ to $p$, because $P^i$ will be used for the ADM momentum

If you remember from our black hole initial conditions paper, the basic idea for many kinds of initial conditions is that of conformal flatness. That is to say, we take our adm metric $\gamma_{ij}$, and perform a conformal transform on it by a scalar, to end up with a conformal metric. In this paper, our ADM variables are transformed as follows:

$$\begin{align}
\gamma_{ij} &= \Phi^4 \bar{\gamma}_{ij}\\
A_{ij} &= \Phi^{-2} \bar{A}_{ij}
\end{align}$$

Where $$\bar{\gamma}_{ij}$$ is the conformally flat (ie the identity matrix) metric tensor, $A_{ij}$ is the extrinsic curvature, and $\Phi$ is the conformal factor. Its important to note that this is the same conformal decomposition as the black hole initial conditions we've used previously[^explicitly]. Similarly, we're trying to solve for exactly two things only in this paper

1. The conformal factor $\Phi$
2. The extrinsic curvature $$\bar{A}_{ij}$$

[^explicitly]: I explicitly picked this paper because it allows us to construct multiple black holes and neutron stars together

The conformally flatness assumption, as well as the maximal slice assumption, gives us a familiar looking constraint to solve:

$$\partial^i \partial_i \Phi = -\frac{1}{8} \Phi^{-7} \bar{A}_{ij} \bar{A}^{ij} - 2 \pi \Phi^5 \mu_H$$

One thing to note is that any time you see a $\pi$, its a sure fire bet that it means there are matter terms involved

|Variable|Meaning|
|-|-|
|$\Phi$|Conformal factor, unknown|
|$\bar{A}_{ij}$| Conformal extrinsic curvature|
|$\mu_H$| Scalar matter source for the ADM equations|

This paper in theory lets us solve the TOV equations in a conformally flat spacetime, via (77-79), but we've deliberately skipping this step, as solving the TOV equations directly is much simpler. In general I wouldn't recommend implementing section VI (other than (83-84)), and I think eq (82) is incorrect unfortunately

## Implementing this paper

The procedure in this paper is as follows:

1. Solve for $\Phi_{tov}$, a conformal factor for the isotropic TOV solution
2. Construct our conformal hydrodynamic variables from our TOV hydrodynamic variables
3. Use these, as well as our ADM momentum and angular momentum to calculate $\bar{A}_{ij}$
4. Use that $\bar{A}_{ij}$ solution to construct $\Phi$, the real conformal factor
5. Construct the final real hydrodynamic variables from the conformal ones defined earlier

## Solving for $\Phi_{tov}$

First off, we need to start over in section VI. Given that we a-priori have our matter distribution, we don't need to solve for $\alpha$, or $\Theta$ luckily, and the only variable we need is $\Phi_{tov}$. There's a nicer way of solving for $\Phi_{tov}$ than specified in the paper, but first we should talk about $\bar{r}$. One thing that absolutely must be noted is that the paper we're working on is in *isotropic* coordinates with the radial coordinate $\bar{r}$. Up until now, we've been working in *schwarzschild* coordinates with the radial coordinate $r$. We're going to have to perform a conversion between the two: the conversion function is defined [as follows (24 + 25)](https://einsteintoolkit.org/thornguide/EinsteinInitialData/TOVSolver/documentation.html#x1-2004r4):

$$\begin{align}
\bar{r} &= C r \mathrm{exp}(\int^r_0 \frac{1 - (1 - 2 \frac{m}{r})^{\frac{1}{2}}}{r(1 - 2\frac{m}{r})^{\frac{1}{2}}} dr)\\
C &= \frac{1}{2R}(\sqrt{R^2 - 2MR} + R - M) \mathrm{exp}(-\int^R_0 \frac{1 - (1 - 2 \frac{m}{r})^{\frac{1}{2}}}{r(1 - 2\frac{m}{r})^{\frac{1}{2}}} dr)
\end{align}$$

Where $R$ is the radius of the star in schwarzschild coordinates, and $M$ is the total rest mass (ie the integral of $m(r)$). Technical details of how this works is available on the linked page

Integrating this is moderately straightforward, and can be done by keeping a running summation of the integral within $\mathrm{exp}$. $m$ is still secretly a function of radius $m(r)$, and is still the cumulative mass from earlier. To get back to the topic at hand, note that we're looking for a $\Phi_{tov}$ from a metric defined as follows:

$$ds^2 = -\alpha^2(\bar{r}) dt^2 + (\Phi_{tov}(\bar{r}))^4(d\bar{r}^2 + \bar{r}^2 d\Omega)$$

The einstein toolkit page lists TOV in isotropic coordinates as:

$$ds^2 = -e^{2\phi} dt^2 +e^{2\Lambda}(d\bar{r}^2 + \bar{r}^2 d\Omega^2)$$

We can see that $e^{2\Lambda} = \Phi_{tov}^4$. And, helpfully, someone smarter[^smrt] than I am has worked out that $e^{\Lambda} = \frac{r}{\bar{r}}$

[^smrt]: [https://physics.stackexchange.com/questions/145342/schwarzschild-metric-in-isotropic-coordinates](https://physics.stackexchange.com/questions/145342/schwarzschild-metric-in-isotropic-coordinates)

This is a much nicer way of calculating this quantity, as $\Phi_{tov} = (\frac{r}{\bar{r}})^\frac{1}{2}$. Do note as an implementation detail, when you're looking up eg a pressure at a radius, you'll want to ensure that you have the ability to look it up by $isotropic$ radius. Ie we need to keep on hand the function $r = f(\bar{r})$, which you should tabulate somewhere

## Calculating the conformal hydrodynamic variables

Once we have $\phi_{tov}$, this is straightforward. We define new conformal variables as such (83-84), keeping in mind that we're using slightly different notation from the paper:

$$\begin{align}
\bar{\mu} &= \Phi_{tov}^8 \mu_{tov}\\
\bar{p} &= \Phi_{tov}^8 p_{tov}
\end{align}$$

These are the only two variables we now need from the hydrodynamics

## Calculating $\bar{A}^{ij}$

From here, its time to dig into the really fun bits. As with our black hole solution, we have two parameters we can specify: the ADM momentum $P^i$, and the ADM angular momentum $J^i$. These are broken up into two equations: (51), and (54) - which we simply sum together

### $P^i$ (linear momentum)

To calculate the contribution from the linear momentum, we need to calculate this equation:

$$\begin{align}
\bar{A}^{ij}_P &=\frac{3Q}{2r^2}(P^i l^j + P^j l^i - (\eta^{ij} - l^i l^j)(P^k l_k)) \\
&+ \frac{3C}{r^4} (P^i l^j + P^j l^i + (\eta^{ij} - 5l^i l^j)(P^k l_k))\\
\end{align}
$$

Here's what everything means

|Symbol|Definition|
|-|-|
|$P^i$|ADM linear momentum|
|$r$|Coordinate distance (in isotropic coordinates) from the neutron star's origin|
|$\eta^{ij}$| The inverse of the conformally flat metric tensor (here: the identity matrix)|
|$l^i$| $l^i=\frac{x^i}{r}$, a unit radial vector|
|$Q$ and $C$| We'll get to these|

The quantities here are trivial to calculate, except for $Q$ and $C$. This is where the information in this paper gets a bit.. scattered, so I'm simply going to present the order of things to calculate

From now on, **our $r$ coordinate is always isotropic**. Variables such as $\bar{\mu}$ should be considered a function of isotropic radius

#### $\mathcal{M}$

The first thing we need is to calculate $\mathcal{M}$. This is straightforward via (59)

$$\mathcal{M} = 4\pi \int^{r_0}_0 (\bar{\mu} + \bar{p}) r^2 dr$$

Integrating this is a straightforward piecewise numerical integration. $r_0$ is the isotropic radius of our neutron star, and $r$ is the integration variable. Note that this quantity is not the same as $M$

#### $\sigma$

Next up, we'll calculate sigma. This is done via (57):

$$\sigma = \frac{\bar{\mu} + \bar{p}}{\mathcal{M}}$$

#### $Q$ and $C$

These functions are both functions of the radius. To emphasise this, I'll specify them as follows:

$$\begin{align}
Q(r) &= 4 \pi \int^r_0 \sigma x^2\; dx\\
C(r) &= \frac{2}{3} \pi \int^r_0 \sigma x^4\; dx\\
\end{align}
$$

When $r > r_0$, $Q(r)=1$, and you should enforce this. The paper does not specify a value for $C(r)$ where $r > r_0$, so I set $C(r) = C(r_0)$ in this region

I personally found the $r'$ notation to be pretty confusing given that its also used for differentiation when I first read this paper, so I've swapped the notation to make it clearer that it is an integration variable. Note that $\sigma$ is also a function, so here we'd be doing $\sigma(x)$

### $J^i$ (angular momentum)

The equation for this is (54):

$$\bar{A}^{ij}_J =\frac{6}{r^3}l^{(i} \epsilon^{{j)}kl}J_k l_l N$$

Here's what everything means

|Symbol|Definition|
|-|-|
|$J^i$|ADM angular momentum (lower with $\eta_{ij}$, here the identity matrix)|
|$r$|Coordinate distance (in isotropic coordinates) from the neutron stars origin|
|$l^i$| $l^i=\frac{x^i}{r}$, a unit radial vector (lower with $\eta_{ij}$)|
|$N$| We'll get to this|
|$\epsilon^{ijk}$| The levi civita symbol|

As previously, we'll dig into the procedure for calculating $N$, and linearise the procedure because the functions are a bit scattered

#### $\mathcal{N}$

You might be wondering if having two functions named $\mathcal{N}$ and $N$ might have resulted in days of confusion for a poor lost developer several years ago, who was reading this as an early paper in their NR journey when they didn't know any better than to be hypervigilant of notational issues

Anyway. Implementing this is under (64):

$$\mathcal{N} = \frac{8 \pi}{3} \int^{r_0}_0 (\bar{\mu} + \bar{p}) r^4\; dr$$

Where $r_0$ is the isotropic radius of our neutron star, and $r$ is the integration variable. Perhaps this goes without saying for people with better reading skills than I, but this function is **not** $N$

#### $\kappa$

(62)

$$\kappa =\frac{\bar{\mu} + \bar{p}}{\mathcal{N}}$$

#### $N$

(55)

$$N(r) = \frac{8 \pi}{3} \int^r_0 \kappa x^4\;dx$$

Remembering that $\kappa(x)$ is a function, and $x$ is the integration variable

When $r>r_0$, $N(r) = 1$, and you should enforce this

## Calculating $\Phi$, the conformal factor

We now have $\bar{\mu}$, $\bar{p}$, and $\bar{A}^{ij} = \bar{A}^{ij}_P + \bar{A}^{ij}_J$. We're going to put this all together, and solve the final piece of our puzzle (22):

$$\Delta \Phi = -\frac{1}{8} \Phi^{-7} \bar{A}_{ij} \bar{A}^{ij} - 2 \pi \Phi^{-3} \bar{\mu}_H$$

This is a standard laplacian. We're going to go over the details of how to perform our full construction after we finish up our next step, which is solving for $\bar{\mu}_H$. Whatever it is, it can't be that bad, right?

Todo: Londo (wesley?)

### Solving for $\bar{\mu}_H$ is indeed that bad

The definition can be found by applying $\Phi_{tov}^8$ to $\mu_H$ (6 + 20):

$$\bar{\mu}_H = (\bar{\mu} + \bar{p})W^2 - \bar{p}$$

Which should be set to $0$ when $r>r_0$. What's $W$?

#### $W$, aka the lorentz factor

There are two lorentz factors in this paper. One for the linear momentum, and one for the angular momentum

Linear (60):

$$W_{P}^2 = \frac{1}{2}\left (1 + \sqrt{1 + \frac{4 P_i P^i}{\mathcal{M}^2}} \right)$$

Angular (65):

$$\begin{align}
W_{J}^2 &=\frac{1}{2}\left (1 + \sqrt{1 + \frac{4 J_i J^i r^2 \sin^2 \theta}{\mathcal{N}^2}} \right)\\
\sin^2 \theta &= 1 - (\hat{J}^i \hat{l}_i)^2 \\
\end{align}$$

$l_i$ is the same unit normal as earlier. For $\sin^2 \theta$, you'll want to ensure that $J^i$ and $l_i$ are normalised (hence the hats) to a length of $1$, as we're using the formula $\mathrm{dot}(a, b) = \cos \theta ||a||\;||b||$. $\theta$ more technically is the angle between $J^i$ and $l^i$. Note that the quantity $\theta$ becomes undefined as $J^i J_i$ tends to $0$, but given the prefix term, we can simply set $\sin^2 \theta$ to anything when this happens

Sometimes I wish I'd taken up fishing

#### Combining lorentz factors

Of course, we can't simply *add* lorentz factors together, that'd be madness. Instead you use the rapidity formula. This gives us:

$$W = \mathrm{cosh}(\mathrm{arccosh}(W_P) + \mathrm{arccosh}(W_J)) $$

With this done, its finally over, and I can now describe the procedure for solving our laplacian

### Solving the laplacian, finally

Here, I'm going to describe how to mix together neutron stars, and black holes. For both neutron stars, and black holes, we have an extrinsic curvature $\bar{A}^{ij}$. For black holes, use the procedure as specified here in Todo article. This is great, we simply sum every extrinsic curvature linearly, and then calculate $\bar{A}^{ij} \bar{A}_{ij}$

Next up, we need to do a bit of work. First off, we need to remember that we can express our conformal factor $\Phi = 1 + u + F$. $u$ is a correction, and what we solve for in the laplacian. We didn't dig into this, but as black holes have no matter distribution, the term $F$ (originally called: $\frac{1}{a}$) is to stop the solution from being trivially conformally flat. This isn't a problem for neutron stars, as you can see in our laplacian we have the term:

$$- 2 \pi \Phi^{-3} \bar{\mu}_H$$

Which is a matter term on the right hand side to prevent it from being flat. To make this all interoperate correctly and give correct solutions, I'll lay out how this works:

|Type|Function|
|-|-|
|Neutron Star|$F_{(i)} = 0$|
|Black Hole| $F_{(i)} = \frac{m_i}{2 \mid \overrightarrow{r} - \overrightarrow{x}_{(i)} \mid}$ |

To calculate $F$, sum over $F_{(i)}$ for every object

The last thing to do is figure out what to do with our individual $\bar{\mu}_H$ terms. Luckily, you simply sum these, and make sure that an individual neutron stars contribution is $0$ outside of its radius. To make this super explicit:

$$\begin{align}
\bar{A}_{ij}^{sum} &= \sum^N_{k=1} \bar{A}_{ij}^{(k)}\\
F^{sum} &= \sum^N_{k=1} F_{(k)} \\
\bar{\mu}^{sum}_H &= \sum^N_{k=1} \bar{\mu}_H^{(k)}\\
\Delta u &= -\frac{1}{8} \Phi^{-7} \bar{A}_{ij}^{sum} \bar{A}^{ij}_{sum} - 2 \pi \Phi^{-3} \bar{\mu}^{sum}_H
\end{align}$$

That's it, we're good to go. From here on, its just a standard laplacian of exactly the same form we solved in todo: this article, and there's absolutely nothing special whatsoever

This lets us solve for our final quantities. Firstly, we'll need some helpers:

|Name|Symbol|Value|
|-|-|-|
| Conformal Angular Adm Matter Source | $$\tilde{S}^J_i$$ | $$\epsilon_{ijk} J^j x^k \kappa(r)$$ ($x$ is the current coordinate world position relative to the star) |
| Conformal Linear Adm Matter Source | $$\tilde{S}^i_P$$ | $$P^i \sigma(r)$$ |
| Conformal Adm Matter Source | $$\tilde{S}^i$$ | $$\tilde{S}^i_P + \eta^{ik} \tilde{S}_k^J$$ |

It is important to note that $\tilde{S}_i^J$ is not simply a function of radius, and is both a function of radius *and* angle. This gives us our final quantities:

|Name|Symbol|Value|
|-|-|-|
|Metric Tensor|$$\gamma_{ij}$$|$$\Phi^4 \eta_{ij}$$|
|Extrinsic Curvature|$$K_{ij}$$|$$\Phi^{-2} \bar{A}_{ij}$$|
| Initial Adm Matter Source | $$\mu_H$$ | $$\Phi^{-8} \bar{\mu}_H$$ |
| Initial Adm Matter Source | $$S^i$$ | $$\Phi^{-10} \tilde{S}^i$$ |
| Initial Pressure | $$P$$ | $$\Phi^{-8} \bar{P}$$ |

## Recovering the hydrodynamic variables

The variables $S^i$ and $\mu_H$ are not actually hydrodynamic quantities, and so we have to construct our final *real* quantities that we could plug into a fluid dynamics simulation.

|Symbol|Name|
|-|-|
|$W$ aka $u^0$| The lorentz factor|
|$u^i$|Fluid 4-velocity (the spatial components)|
|$\rho_0$|Rest mass density|
|$\mu$|Total mass-energy density|
|$p$|Pressure|

We unfortunately cannot simply transform our conformal variables, as they are not actually equivalent. We must instead construct them from $S^i$ and $\mu_H$. To do this, we have the following equations:

$$\begin{align}
\mu_H &= (\mu + p) W^2 - p \\
\gamma_{ij} S^i S^j &= (\mu + p)^2 W^2 (W^2 - 1)
\end{align}$$

Initially this might seem a tad unsolvable, but we have an equation of state that you can use to tie together $\mu$ and $p$. This paper leaves out the fact that there is no easy solution to this series of equations, and so I'll detail the procedure for solving this

1. Make an initial guess for $W_0=1$ and $\mu_0 = \mu_H$
2. Numerically find a $\mu$ such that $(\mu_n + p) W^2 - p = \mu_H$, giving $\mu_{n+1}$. I do a simple linear search. You'll also have to invert the equation of state to go from $\mu$ -> $p$, which I tabulate and bruteforce as its fairly quick to search
3. Calculate $W_{n+1} = \frac{\sqrt{1 + \sqrt{4 \frac{\gamma_{ij} S^i S^j}{(\mu + p)^2} + 1}}}{\sqrt{2}}$
4. Iterate until the desired accuracy is reached

This is applying fixed point iteration to these two equations to solve them simultaneously. Once you've solved for $W$ and $\mu$, then calculate $u^i = \frac{S^i}{(\mu + p)W}$. The full fluid 4-velocity is $(W, u^i)$
