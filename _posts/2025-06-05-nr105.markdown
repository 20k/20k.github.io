---
layout: post
title:  "Numerical Relativity 105: Smashing neutron stars together like its 2002"
date:   2026-02-02 12:33:23 +0000
categories: C++
published: false
---

Hi! Its finally time to do something truly spectacular, and smash some neutron stars together. We'll be discussing how relativistic hydrodynamics works, how it compares to regular hydrodynamics, and some of the various approaches present in the literature

If you're here simply for the montage of black holes eating neutron stars: good news, there's a compilation at the end of this article

But first up: Some background

# What is hydrodynamics?

If you're like me, at some point you might not even really have known why hydrodynamics is a separate area of inquiry to just solving PDEs in general. Or, you might just think its an umbrella term for people who apply the same techniques we've been using already, but simply to fluids

This is incorrect. A fair chunk of this article is going to be explaining what hydrodynamics is, why we need to use different solving methods, and how that fits into general relativity. A lot of programmers' experience of fluid dynamics is the incompressible Navier-Stokes equations, so you might be wondering how similar that it is to what we're trying to do today (disclaimer: not very)

So today's article is going to contain a fair bit of information about regular hydrodynamics

There are three major classes of hydro formalisms

## Lagrangian

In the lagrangian approach, we track a number of particles around a grid. This is common in techniques like smooth particle hydrodynamics. In essence, you can construct a pseudo fluid at each point by interpolating particle properties, and then moving your particles along. We won't be going near this today, but it *is* used occasionally for GR

Lagrangian formalisms don't need grid cells, as their primary unit of information is the particle

Todo: Pictures

## Semi-Lagrangian

If your understanding of hydro is the programmers' understanding, the common style of solving Navier-Stokes is known as a Semi-Lagrangian scheme. In this approach, we have a series of grid cells representing our fluid. At each point, you look up the current cell's velocity, and trace backwards in time to find out where it could have originated from, and look up fluid quantities there

Because we're tracing backwards on our grid as if we're a particle, this is vaguely a halfway house between the Lagrangian approach, and the Eularian approach, which we're about to get to

Todo: Pictures

## Eularian

In this approach, we discretise the same as the Semi-Lagrangian approach, with our fluid properties in grid cells. However, we update our fluid quantities purely *locally*. To find our cell's update, its a function of the velocity around the cell, which we estimate via the derivatives

The Eularian approach is what we'll be doing today. It matches well to General Relativity - as it does not involve any kind of non-local (or a-causal) estimates, through a curved spacetime - except as introduced via discretisation

We'll get to the differences between hydro, and simple PDE solving, after we introduce the relativistic portions of this article. There are a bunch of other techniques as well like lattice Boltzmann if you're interested, this is just the major schemes

Todo: Pictures

# Relativistic Eularian Hydrodynamics

We're going to be looking at two papers today, primarily the latter:

[Fully general relativistic simulation of coalescing binary neutron stars: Preparatory tests](https://arxiv.org/pdf/gr-qc/9908027)

[Hydrodynamic Simulations in 3+1 General Relativity](https://arxiv.org/pdf/gr-qc/0209102)

Note that there was a significant shift in approach from the first paper, to the second, and we'll be using the second's notation and equations

In this approach, we have the following variables for our fluid dynamics:

|Notation | What does it represent |
|-|-|
|$\rho_*$| Rest mass |
|$e_*$| Energy |
|$\tilde{S}_k$ | Momentum (ish) |

This is what we'll be evolving directly. Note that I've translated the paper's old-style conformal factor $\phi$, into our newer conformal factor $W$. A table of conversions is provided at the end of this article

We have the following definitions:

|Variable |Definition | Notes |
|-|-|-|
|$\rho_*$ | $\rho_0 \alpha u^0 W^{-3} $ | |
|$e_*$ | $(\rho_0 \epsilon)^\frac{1}{\Gamma} \alpha u^0 W^{-3}$ | Unclear how a numerical equation of state would work, or if a varying $\Gamma$ is valid |
|$\tilde{S}_k$ | $\rho_* h u_k$ | |
| $h$ | $1 + \epsilon + \frac{P}{\rho_0}$ | $1 + \Gamma \epsilon$ with the perfect fluid equation of state, $P = (\Gamma - 1) \rho_0 \epsilon$ |
|$w$ | $\rho_* \alpha u^0$ | Must be calculated via an iterative procedure |
|$v^i$ | $\frac{u^i}{u^0}$ | Represents a coordinate velocity |

The notation in this article is harmonised with the previous one. $\rho_0$ is the rest-mass density, $\epsilon$ is the specific energy density, $u^0$ is the lorentz factor, and $\alpha$ is the lapse. I won't be fighting with the paper, and we'll be using a perfect fluid equation of state

## Initialising our variables

At the end of the previous article, we ended up with our fluid quantities: $\rho_0$, $\epsilon$, $u^i$, and $u^0$

There are two pitfall traps here:

1. The initial procedure we used last time appears to have assumed implicitly that $\alpha = 1$, and $\beta^i = 0$ - so use these when initialising regardless of what you actually pick for them
2. $u_i = \beta^i u^0 + \gamma_{ik} u^k$. If you want to prove this, calculate $u_i = g_{i\nu} u^\nu$. There's maths in the appendix

We can now carry on immediately from our last article, which follows on as such:

```c++
valuef pressure = mu_to_P(mu);
valuef p0 = pressure_to_p0(pressure);

valuef epsilon = (mu / p0) - 1;

//with raised index
v3f ui = Si / ((mu + pressure) * u0);

valuef gA = 1;
v3f gB = {0,0,0};

valuef p_star = p0 * gA * u0 * pow(cW, -3);
valuef e_star = pow(p0 * epsilon, (1/Gamma)) * gA * u0 * pow(cW, -3);

v3f u_i;

for(int i=0; i < 3; i++)
{
    valuef sum = 0;

    for(int k=0; k < 3; k++)
    {
        sum += Yij[i, k] * ui[k];
    }

    u_i[i] = gB[i] * u0 + sum;
}

valuef h = calculate_h_from_epsilon(epsilon);

v3f Si_lo_cfl = p_star * h * u_i;

as_ref(hydro.p_star[pos, dim]) = p_star;
as_ref(hydro.e_star[pos, dim]) = e_star;
as_ref(hydro.Si[0][pos, dim]) = Si_lo_cfl[0];
as_ref(hydro.Si[1][pos, dim]) = Si_lo_cfl[1];
as_ref(hydro.Si[2][pos, dim]) = Si_lo_cfl[2];
```

Where:

```c++
valuef calculate_h_from_epsilon(valuef epsilon)
{
    return 1 + get_Gamma() * epsilon;
}
```

That's it, no other surprises

## Evolution equations

So far, so good. Lets look into the basic set of evolution equations [(26-28)](https://arxiv.org/pdf/gr-qc/0209102):



$$\begin{align}
\partial_t p_* + \partial_i(p_* v^i) &= 0\\
\partial_t e_* + \partial_i(e_* v^i) &= 0\\
\partial_t \tilde{S}_k + \partial_i(\tilde{S}_k v^i) &=
                       - \alpha \frac{1}{W^3} \partial_k P - w h \partial_k \alpha \\
                       &-\tilde{S}_j \partial_k \beta^j + \frac{\alpha W^2\tilde{S}_i \tilde{S}_j}{2wh} \partial_k \tilde{\gamma}^{ij}\\
                       &+ \frac{\alpha h(w^2 - p_*^2)}{w} \frac{\partial_k W}{W}
\end{align}
$$

### The reason hydrodynamics is a thing

We'll get around to some implementing soon. But first: lets talk about these equations in a generic form:

$$\begin{align}
\partial_t p_* &+ \nabla  (p_* \textbf{v}) = 0\\
\partial_t e_* &+ \nabla  (e_* \textbf{v}) = 0\\
\partial_t \tilde{S}_k &+ \nabla  (\tilde{S}_k \textbf{v}) = Source\\
\end{align}$$

Or more generally:

$$
\partial_t q + \nabla (q \textbf{v}) = Source
$$

This is the standard representation in hydrodynamics of advection equations, with the right hand side being called a source term (which you shouldn't confuse with an ADM source term). In general, the source terms are split out, and no special treatment is given to their solving, so we're going to now unceremoniously ignore them

In hydrodynamics there are things called *conserved quantities* - like rest mass, energy, and momentum for a fluid dynamics simulation. The idea behind a conserved quantity is that we want it to be conserved (unsurprisingly), ie a good simulation should keep the total rest mass exact

Naively, you might think to discretise $\partial_i(p_* v^i)$ as something like this, like all our other derivatives:

```c++
auto do_p_star = [&](valuef p_star, v3f v, int i) {
    return diff1(p_star * v[i], i, d);
};

valuef sum = 0;

for(int i=0; i < 3; i++) {
    sum += do_p_star(p_star, v, i);
}
```

This kind of discretisation makes no guarantees about conservation. While it will work, in general the hydro people will be very angry at you, and your simulation will be physically very suspect. What's the alternative?

# Hydrodynamics 101: A crash course

This is one of the few times we'll be chatting about something which isn't directly general relativity, which puts this outside my expertise. If you do hydrodynamics and know cool things about fancy high resolution schemes: please get in touch

Eularian hydrodynamics in general is concerned with solving equations of this form:

$$\partial_t q + \nabla (q \textbf{v}) = Source$$

This is generally broken up into three 1D problems (which are summed):

$$\partial_t q + \partial_x(q v_x) = Source$$

Good techniques for solving this have the following properties:

1. They conserve your quantity $q$
2. They handle 'shocks', ie discontinuities in $q$
3. They don't produce oscillations that build up and cause everything to break

| Term | Meaning|
|-|-|
| Finite Volume | A method of discretising the equations, so we can guarantee conservation |
| Shock capturing | Everything doesn't blow up when there are discontinuities in $q$, like drastic pressure changes |
| Total Variation Dimishing (TVD) | The discretisation method doesn't produce increasing oscillations near discontinuities |
| High resolution | Has a higher spatial order of 2+ in smooth parts of the solution. Currently, we're a 4th order NR sim |

In numerical relativity, 'shocks' are partially handled via Kreiss-Oliger dissipation[^ramble] - but the equations don't tend to produce the kinds of errors you can get with hydrodynamics. Kreiss-Oliger isn't really appropriate to hydrodynamics, as it is not a conservative solution - we'll end up with a fluctuating mass or something

[^ramble]: Kreiss-Oliger dissipation is only intended to handle problems that build up as a result of finite difference truncation errors. These can cause oscillations. It is however implicitly - perhaps unintentionally - used to smooth the grid in general. Particularly, singularities (being a discontinuity, ie a shock) are smoothed out by Kreiss-Oliger, which damps it. I don't know that this multipurpose function of Kreiss-Oliger is strictly intended, but it appears to be common. Shocks in NR also appear to be uncommon in practice, whereas they are very common in fluid dynamics necessitating different solving techniques

[Appendix A](https://arxiv.org/pdf/gr-qc/0209102) in the paper we're looking at describes a hydro treatment: but as far as I can tell, it does not work at all. We're going to have to come up with something different, which means: learning

## Discretisation

https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf

The basic form of these discretisations is as follows. First off, we define a *flux* as the following quantity:

$$f_i = v_i q_i$$

$_i$ is a grid cell offset - I'm not going to try and fight hydro notation, its just going to clash terribly with tensor index notation and we'll live with it. The basic discretisation scheme is then as follows:

https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf 4.4

$$\partial_t q = \frac{1}{\Delta x} (F^n_{i-\frac{1}{2}} - F^n_{i+\frac{1}{2}})$$

where $\Delta x$ is the scale. This is the flux conserving form, and is generic across any hydrodynamics scheme. Solving for the half grid cell flux at the boundary between our grid cells is the joy of hydrodynamics

High resolution schemes often mix and match between different orders in different smoothness areas - having a lower order in less smooth areas. There's some interesting [theoretical reasons](https://en.wikipedia.org/wiki/Godunov%27s_theorem) as to why

I'm not going to attempt to document hydrodynamics in general here, so its time to look at a specific form of solving this equation. It fulfills all the requirements for a 'good' technique, as well as the major requirement which is having a workable set of equations that I can implement[^implement]

[^implement]: Going for a dig through the hydrodynamics literature is surprising. Every field develops its own notation and language, and hydrodynamics appears to have developed its own convention for which steps are omitted when describing a particular scheme. Finding documentation on those omitted steps is surprisingly challenging. That's the core reason why these articles come with a working, testable implementation that you can dig through, and why code often makes much better documentation than papers in my experience

https://www.astro.uzh.ch/~stadel/lib/exe/fetch.php?media=spin:compastro_godunov.pdf todo: contains a note on flux

## A specific scheme: MUSCL

This scheme swaps between second order, and first order, by using a limiter function on how much fluid can be transported from one cell to the next. Different limiters have different properties - some introduce lots of diffusion, some accidentally introduce oscillations. The most common, least diffusive limiter, appears to be known as 'superbee', which we'll be using

These limited functions then have upwinding applied to them, to result in a stable scheme. There's two different forms of these equations, slope limited, and flux limited

### Slope limited

https://arxiv.org/pdf/1705.10608

https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf 6.30
6.32

$$\begin{align}
u_{i - \frac{1}{2}} &>= 0 \\
F^n_{i - \frac{1}{2}} &= u_{i - \frac{1}{2}} q_{i - 1} + \frac{1}{2} u_{i - \frac{1}{2}} (\Delta x - u_{i - \frac{1}{2}} \Delta t) \sigma_{i-1}\\
\\
u_{i - \frac{1}{2}} &<= 0 \\
F^n_{i - \frac{1}{2}} &= u_{i - \frac{1}{2}} q_{i} - \frac{1}{2} u_{i - \frac{1}{2}} (\Delta x + u_{i - \frac{1}{2}} \Delta t) \sigma_{i}\\
\end{align}
$$

$\sigma_i$ is a a slope limiter

### Flux limited

$$\begin{align}
F^n_{i - 1/2} &= u_{i - 1/2}^- q_i + u_{i - 1/2}^+ q_{i - 1} + \frac{1}{2} \mid u \mid (1 - \mid \frac{u_{i - 1/2} \Delta t}{\Delta x} \mid) \delta_{i - 1/2}\\
\\
\Delta q_{i - 1/2} &= q_i - q_{i - 1}\\
\delta_{i-1/2} &= \phi(\theta_{i - 1/2}) \Delta q_{i - 1/2}\\
\bar{u}^+_{i-1/2} &= \mathrm{max}(\bar{u}_{i-1/2}, 0)\\
\bar{u}^-_{i-1/2} &= \mathrm{min}(\bar{u}_{i-1/2}, 0)\\
\\
\theta_{i - 1/2} &= \frac{\Delta q_{I-1/2}}{\Delta q_{i-1/2}}\\
\end{align}
$$

Where:

$$
u_{i - 1/2} > 0\\
I = i-1\\
u_{i - 1/2} < 0\\
I = i + 1\\
$$

$\phi$ is a *flux* limiter. There's nothing fundamentally that different here to the slope limiting equations, its just a different way of limiting stuff. We'll be using the superbee limiter: todo

## The half velocity

Todo: I'm going to have to find a proper advection source

There are two ways that I've seen to calculate this half velocity:

1. $v^{n}_{i - 1/2} = \frac{v^{n}_{i} + v^{n}_{i - 1}}{2}$

Todo: Conventional third order is good https://ntrs.nasa.gov/api/citations/20080018695/downloads/20080018695.pdf

fsa

fd
f
f
f
f
f
f
f
f
f
f
f
f
d
fs
f
sdf

fd



There are two nontrivial quantities we need to calculate here, $v^i$ and $w$

### $v^i$

Firstly, we calculate $u_k = \frac{\tilde{S}_k}{p_* h}$

The quantity $v^i$ is as follows:

$$v^i = -\beta^i + \frac{W^2 \alpha \tilde{\gamma}^{ij} \tilde{S}_j}{w h}$$

This can either be worked out from [2.12](https://arxiv.org/pdf/gr-qc/9908027) and converting their variables, or by calculating $\frac{u^i}{u^0}$ as $$g^{i\nu} u_{\nu}$$. You'll also have to work out the quantity $u_0$ if you're deriving this by hand. Todo: Do this at the endof the article

### $w$

This quantity is much less fun. It has the following form (29):

$$w^2 = p_*^2+ W^2 \tilde{\gamma}^{ij}\tilde{S}_i \tilde{S}_j \left[1 + \frac{\Gamma e_*^{\Gamma}}{p_*(w \frac{e^{6\phi}}{p_*})^{\Gamma-1}} \right]^{-2}$$

There are two problems:

1. There is no analytic solution
2. It divides by zero a fair bit

We can solve #1 by using fixed point iteration with the initial guess $w=\rho_*$ as this is a lorentz factor multiplied by density terms. Simply plug in your guess into the right hand side, calculate the new value of $w$, and rinse and repeat. #2 is more of a pain

The way this equation is structured is mildly unimplementable. Lets rearrange it a bit:

$$\begin{align}
A &= (W^3)^{\Gamma-1}\\
D &= \frac{w^{\Gamma-1}}{w^{\Gamma-1} + A \Gamma e_*^{\Gamma} p_*^{\Gamma-2}}\\
w^2 &= p_*^2 + W^2 \tilde{\gamma}^{ij} \tilde{S}_i \tilde{S}_j D^2\\
\end{align}
$$

The singular part is the divisor of $D$, and to fix it you can simply clamp the bottom to a small constant. We'll be getting back to the singular division issue later, as we'll be handling it systematically

Its worth noting here that when $\Gamma = 2$, the factor of $p_*$ drops out



Start old article

Some things are easy. Some things are hard. Some things are neutron star collisions. Lets get into it

# Relativistic Eularian Hydrodynamics

We're going to be looking at two papers today, primarily the latter:

[Fully general relativistic simulation of coalescing binary neutron stars: Preparatory tests](https://arxiv.org/pdf/gr-qc/9908027)

[Hydrodynamic Simulations in 3+1 General Relativity](https://arxiv.org/pdf/gr-qc/0209102)

We're going to modify this paper a little to remove some divergent quantities

We'll also need to perform the standard modifications to the BSSN equations to add matter terms in

## Paper notation and equations

|Paper Notation | Description |
|-|-|
|$\rho$| ADM scalar matter source. We'll be calling this $\rho_s$ to avoid confusion |
|$S_i$| ADM vector matter source. Also known as $j_i$ |
|$S_{ij}$| ADM tensor matter source |
|$S$ | The trace of $S_{ij}$ with respect to $\gamma_{ij}$|
|$\rho_*$| Evolution variable related to the fluid's matter density |
|$e_*$| Evolution variable related to the fluid's energy |
|$\tilde{S}_k$ | Evolution variable related to the fluid momentum|
|$u^i$ | Spatial part of the fluid 4-velocity |
|$u^0$| The lorentz factor (the first component of the fluid 4-velocity)|
|$w$| $p_* \alpha u^0$, used to calculate the lorentz factor|
|$v^i$ | The coordinate 3-velocity|
|$P$ | Pressure. We'll be using their notation instead of $p$|

The convention that they use for the fluid variables lines up with ours

$\rho_s$, $S_i$ and $S_{ij}$ together make up the components of the stress energy tensor $T_{\mu\nu}$

$\rho_*$, $e_*$, and $\tilde{S}_k$ are what we'll be solving the evolution equations for

We'll also need to convert this papers older style conformal factor $\phi$, to ours which is $W$. The conformal decomposition is defined as follows: $$\tilde{\gamma}_{ij} = W^2 \gamma_{ij} = e^{-4\phi} \gamma_{ij}$$

|Ours|Theirs|
|-|-|
|$W$|$e^{-2\phi}$|
|$W^2$|$e^{-4\phi}$|
|$W^3$|$e^{-6\phi}$|
|$\frac{1}{W}$|$e^{2\phi}$|
|$\frac{1}{W^2}$|$e^{4\phi}$|
|$\frac{1}{W^3}$|$e^{6\phi}$|
|$-\frac{\partial_i W}{2W}$|$\partial_i \phi$|

This is basic, but it saves a lot of time looking things up when you check the reference paper

## Initial conditions

First off, we need to translate from our hydrodynamic quantities, to this paper's quantities. We'll also need the equation of state for a perfect fluid, which is $P = (\Gamma - 1) \rho_0 \epsilon$, where $\Gamma = 2$

|Symbol | Initial value |
|-|-|
|$\rho_0$ | Numerically calculated from the inverted neutron star equation of state from $P$ and $\mu$. For a polytrope, this is $\mu = \rho_0 + \frac{P}{\Gamma - 1}$  |
|$\rho_*$| $\rho_0 \alpha u^0 W^{-3}$ |
|$\rho_0 \epsilon $| $\frac{P}{\Gamma - 1}$ (perfect fluid EoS)|
|$e_*$| $(\rho_0 \epsilon)^{\frac{1}{\Gamma}} \alpha u^0 W^{-3}$|
|$u_i$ | $\beta^i u^0 + \gamma_{ij} u^j$|
|$\tilde{S}_k$| $\rho_* h u_k$ |

We already have the lorentz factor $u^0$ from our initial conditions, as well as distributions for $P$, $\mu$, and $u^i$. $u_i$'s derivation can be worked out by lowering $u^\mu$ with the metric tensor $g_{\mu\nu}$

Note that $\alpha = 1$ and $\beta^i = 0$ for us, as these were assumed in the construction of our initial conditions in the last article. This is different from the initial values we'll be using for the evolution, confusingly

## Evolution Equations

The equations themselves are straightforward:

$$\begin{align}
\partial_t p_* = &-\partial_i(p_* v^i)\\
\partial_t e_* = &-\partial_i(e_* v^i)\\
\partial_t \tilde{S}_k = &-\partial_i(\tilde{S}_k v^i) \\
                       &- \alpha \frac{1}{W^3} \partial_k P - w h \partial_k \alpha \\
                       &-\tilde{S}_j \partial_k \beta^j + \frac{\alpha W^2\tilde{S}_i \tilde{S}_j}{2wh} \partial_k \tilde{\gamma}^{ij}\\
                       &+ \frac{\alpha h(w^2 - p_*^2)}{w} \frac{\partial_k W}{W}
\end{align}
$$

There are two nontrivial quantities we need to calculate here, $v^i$ and $w$

### $v^i$

Firstly, we calculate $u_k = \frac{\tilde{S}_k}{p_* h}$

The quantity $v^i$ is as follows:

$$v^i = -\beta^i + \frac{W^2 \alpha \tilde{\gamma}^{ij} \tilde{S}_j}{w h}$$

This can either be worked out from [2.12](https://arxiv.org/pdf/gr-qc/9908027) and converting their variables, or by calculating $\frac{u^i}{u^0}$ as $$g^{i\nu} u_{\nu}$$. You'll also have to work out the quantity $u_0$ if you're deriving this by hand. Todo: Do this at the endof the article

### $w$

This quantity is much less fun. It has the following form (29):

$$w^2 = p_*^2+ W^2 \tilde{\gamma}^{ij}\tilde{S}_i \tilde{S}_j \left[1 + \frac{\Gamma e_*^{\Gamma}}{p_*(w \frac{e^{6\phi}}{p_*})^{\Gamma-1}} \right]^{-2}$$

There are two problems:

1. There is no analytic solution
2. It divides by zero a fair bit

We can solve #1 by using fixed point iteration with the initial guess $w=1$ (or perhaps, $w=p_*$) as this is a lorentz factor multiplied by density terms. Simply plug in your guess into the right hand side, calculate the new value of $w$, and rinse and repeat. #2 is more of a pain

The way this equation is structured is mildly unimplementable. Lets rearrange it a bit:

$$\begin{align}
A &= (W^3)^{\Gamma-1}\\
D &= \frac{w^{\Gamma-1}}{w^{\Gamma-1} + A \Gamma e_*^{\Gamma} p_*^{\Gamma-2}}\\
w^2 &= p_*^2 + W^2 \tilde{\gamma}^{ij} \tilde{S}_i \tilde{S}_j D^2\\
\end{align}
$$

The singular part is the divisor of $D$, and to fix it you can simply clamp the bottom to a small constant. We'll be getting back to the singular division issue later, as we'll be handling it systematically

Its worth noting here that when $\Gamma = 2$, the factor of $p_*$ drops out

### Recovering the primitive variables

$\rho_0$ and $\epsilon$ are called the primitive hydrodynamic variables, and recovering them requires $w$. Once you have that, you can calculate:

$$\begin{align}
\rho_0 &= \frac{W^3 p_*^2}{w}\\
\epsilon &= e_*^\Gamma p_*^{\Gamma - 2} (\frac{W^3}{w})^{\Gamma - 1}
\end{align}
$$

Other usefully optimised quantities are:

$$\begin{align}
\rho_0 \epsilon &= \left (e_* W^3 \frac{p_*}{w} \right)^\Gamma\\
h &= 1 + \Gamma \epsilon
\end{align}
$$

## ADM Source terms

There are four standard adm source terms. These make up the components of the stress energy tensor, which are fed into our ADM equations to make matter work

$$\begin{align}
\rho_s &= h w W^3 - P\\
S_i &= W^3\tilde{S}_i\\
S_{ij} &= \frac{W^3}{wh}\tilde{S}_i \tilde{S}_j + P \gamma_{ij}\\
S &= \gamma^{ij} S_{ij} = W^2 \tilde{\gamma}^{ij} S_{ij} \\
\end{align}$$

There's a minor problem: $S_{ij}$ is singular at the singularity. The issue is that $\gamma_{ij}$ is undefined

Luckily, we can skip to the future, and discover that the form of our $S_{ij}$ source term is actually: $-W^2 8 \pi \alpha S_{ij}$[^alttechnique]. Given that $$W^2 \gamma_{ij} = \tilde{\gamma}_{ij}$$, we can instead re-format our equation like this:

[^alttechnique]: Calculating the pressure involves calculating the quantity $\rho_0 \epsilon$: we could scavenge one of the $W^2$ terms from that calculation to instead remove the $\gamma_{ij}$ term. However, the construction presented is a slightly more general approach that we can use in other methods, rather than relying on the *specific* form of the source terms, so we'll stick with it

$$
\begin{align}
\tilde{S}_{ij} &= \frac{W^5}{wh} \tilde{S}_i \tilde{S}_j + P \tilde{\gamma}_{ij}\\
S &=\tilde{\gamma}^{ij} \tilde{S}_{ij} \\
\end{align}
$$

We'll have to modify our BSSN source term to match the absorbed $W^2$ term, but now our source terms become regular at the metric tensor. This is a minor improvement over the standard arrangement

## The BSSN equations

The modifications are straightforward:

$$\begin{align}
\partial_t K &\mathrel{+}= 4 \pi \alpha (S + \rho_s)\\
\partial_t \tilde{A}_{ij} &\mathrel{+}= -8 \pi \alpha \tilde{S}_{ij}^{TF}\\
\partial_t \tilde{\Gamma}^i &\mathrel{+}= -16 \pi \alpha \tilde{\gamma}^{ij} S_j\\
\mathcal{H} &\mathrel{+}= -16 \pi \rho_s\\
\mathcal{M}_i &\mathrel{+}= -8 \pi S_i\\
\end{align}$$

The source terms conspire very conveniently to avoid having to calculate infinite quantities at the singularity which is great. The only infinities we have to worry about are in the actual hydrodynamic evolution equations themselves

## Implementation Details

### Divisions by zero

As you may have noticed, our equations involve quite a bit of dividing by zero. In general, there are many instances of divisions by $w$, or $W$, which we'll have to deal with

In general, dealing with this is pretty straightforward. For division by $W$, I clamp $W$ to $0.1$. This might seem quite large, but in general we don't really care about the hydrodynamics near the singularity of a black hole, and its more important for the equations to remain regular

For divisions by equations involving $\rho_*$ or $w$, I use a division tolerance of $1e-6$

### Stability

#### Non atmospheric hydrodynamics

One of the key aspects of this paper is the non-atmospheric aspect of it. The idea here is that when $\rho_* < \rho_{min}$ (here, $1e-8$), you flush all your evolution variables to $0$ for a true vacuum. This is a tad unusual as hydrodynamics goes, but it does leave a few questions about exactly how and when to flush your evolution variables to zero

We're using a pretty different integration scheme (backwards euler) compared to the paper. You may be tempted to flush variables to zero at the end of a backwards euler substep, but this is actually the wrong choice. Consider that the next backwards euler iteration is calculated as:

$$next = base + f(in)$$

If our cell value is just below $\rho_{min}$, and our neighbours are above, in the next iteration there'll be effectively a hole in the simulation grid which fluid will rush into. Because $base$ is nonzero, this means that we'll end up with too much fluid in our current cell. This can cause an oscillatory behaviour which doesn't converge very well

Instead, I copy the current cell value over if $\rho_* < \rho_{min}$, and only perform a flush after the whole backwards euler substep is resolved

#### Operator Splitting

Our equations are of the form:

$$\partial_t X + \partial_i (X v^i) = \mathrm{rhs}$$

Operator splitting means that you update all the advection terms first, and then evaluate the rhs post advection. You might notice that this is effectively a backwards euler step given that our right hand size is $0$ for most of our evolution variables. In general, this is something you don't need to worry about with a stable integrator

I did some fairly extensive testing of various operator splitting methods vs treating these as regular evolution equations for this article, and was not able to find any stability difference at all. Operator splitting requires a few extra buffers for storage of intermediate variables, so in this case it was strictly worse

#### Artificial Viscosity

There are two reasons to introduce artificial viscosity

1. To deal with shocks, ie discontinuities
2. To damp the oscillations that occur as a result of our approximate initial conditions

To do this, you modify the $\partial_k P$ pressure term in the evolution of $$\tilde{S}_k$$ extra viscous term. There are two complementary ways to modify this

1. Quadratic viscosity
2. Linear viscosity

##### Quadratic Viscosity

$$\begin{cases}
P_{Qvis} = C_{Qvis}A(\delta v)^2\;\;\mathrm{for} \;\delta v < 0\\
0 \; \mathrm{otherwise}
\end{cases}$$

Where:

$$\begin{align}
A &= e_*^\Gamma (W^3)^{\Gamma-1} \frac{p_*^{\Gamma-1}}{w^{\Gamma-1}}\\
\delta v &= 2 \partial_k v^k \Delta h
\end{align}$$

Where $$\Delta h$$ is the scale. $C_{Qvis}$ is a damping constant, which I set to $1$, and this paper recommends the range $[0.1, 1]$

Quadratic viscosity is generally left on throughout a simulation

##### Linear viscosity

$$\begin{cases}
P_{Qvis} = -C_{Lvis}\sqrt{(\Gamma/n) p_* A}\;\;\mathrm{for} \;\delta v < 0\\
0 \; \mathrm{otherwise}
\end{cases}$$

$C_{Lvis}$ is a damping constant in the range $[0, 1]$. In my case, I set this damping constant as follows:

$$C_{Lvis} = e^{-\frac{t^2}{2 S^2}}$$

$S$ is a constant that represents a damping timescale for the linear viscosity, as it is generally only useful in the early parts of the simulation to iron out the star's oscillations

##### Viscosity $e_*$

When using viscosity, you have to modify the evolution equation of $e_*$. The term to add is:

$$\partial_t e_* += -(\rho_0 \epsilon)^{(-1 + \frac{1}{\Gamma})} \;\; \frac{P_{extra}}{\Gamma} \; \partial_k (\frac{w W^{-3} v^k}{p_*})$$

#### Black Hole Collapse

Matter within a black hole in the set of equations I'm presenting here is only moderately badly behaved at the singularity, which is frankly incredible. You do need to do two things to make this work well

1. Disable all viscosity in the vicinity of an event horizon
2. Dissipate all the matter fields to zero when within an event horizon

In general, the lapse $\alpha$ is a good surrogate variable for being near an event horizon. I use a conservative $0.45$ for disabling viscosity, and $0.15$ for dissipating matter fields. The latter constraint imposes a minimum simulation resolution to successfully simulate a black hole

#### Boundaries

The sommerfeld boundary conditions I find tend to be a bit unstable with matter. Simply damping the fields away to zero as they approach the boundary works very well

#### Velocity clamping

One persistent problem I have run into in this simulation is $$\tilde{S}_k$$ blowing up to infinitely high values. There doesn't appear to be any particular constraints on this variable, which can lead to the fluid acquiring rather crazy velocities

To fix this, after a backwards euler subset, I enforce a constraint to limit the maximum velocity that the fluid can take:

```c++
    valuef bound = 0.9f;

    valuef p_star = hydro.p_star[pos, dim];
    valuef e_star = hydro.e_star[pos, dim];

    v3f Si = {hydro.Si[0][pos, dim], hydro.Si[1][pos, dim], hydro.Si[2][pos, dim]};
    pin(Si);

    valuef w = calculate_w(p_star, e_star, args.W, args.cY.invert(), Si);
    valuef epsilon = calculate_epsilon(p_star, e_star, args.W, w);
    valuef h = calculate_h_from_epsilon(epsilon);

    valuef cst = p_star * bound * h;

    v3f clamped = clamp(Si, -cst, cst);

    as_ref(hydro.Si[0][pos, dim]) = clamped[0];
    as_ref(hydro.Si[1][pos, dim]) = clamped[1];
    as_ref(hydro.Si[2][pos, dim]) = clamped[2];
```

Luckily we can avoid calculating the actual fluid velocity $u_k$. This step is also necessary to stabilise fluid inflowing into an event horizon

The bound of $0.9$ is arbitrary. There is likely a theoretical reason to derive a value $< 1$, as that is the maximum stable value under testing

#### Kreiss-Oliger

All hydrodynamic fields have Kreiss-Oliger damping applied to them at the same strength as the BSSN variables

#### Leibnitz

As mentioned previously, there are ambiguities as to when to flush the evolution variables to $0$. One thing to keep in mind is that you may be tempted to apply a standard Leibnitz rule to the following expression:

$$\partial_k (X v^k) = (\partial_k X) v^k + (\partial_k v^k) X $$

In the implementation strategy I chose, I flush $v$ to zero when calculated, which makes these two quantities quite inequivalent when discretised. Its not wrong to do so, but you may find stability differences if you're expanding out the partial derivatives rather than calculating them directly

#### e_* blows up

One known consequence of the atmosphere-free formulation is that a thin (resolution dependent) shell of material drifts away from the star, and remains suspended around it. This isn't ideal, but currently I'm unaware of anything that can be done to prevent this. This thin shell can end up superheating, causing unfun code times. This is a similar problem to fluid accelerating massively

This paper fixes it by clamping $$e_* = min(e_*, 10 \rho_*)$$. I do this when $\rho_* < 10\rho_{min}$, though I haven't found this modification is terribly important in practice

#### Unphysical oscillations, and gauge collapse

The paper mentions some oscillations appear to increase as time goes on, though they also mark them as non-relevant. While I'm not sure exactly whether or not the following test case is what they describe, I did notice something odd when looking at an isolated neutron star:

<iframe width="560" height="315" src="https://www.youtube.com/embed/To-_85LlW8g?si=tnZYw1nmhKpH1jvx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

This took me a very hot minute to track down. It appears that there's an unfortunate coupling between the $\partial_k \alpha$ term in the evolution equations, and the BSSN evolution equations themselves

You see, at the begining of the simulation, the star wants to collapse to a stable state. On top of this, the initial gauge conditions are *also* a guess, and *also* want to collapse to a stable state. The combination of these two mutually dependent collapses happening simultaneously appears to cause an ever increasing series of oscillations

Luckily, we already completely accidentally have the cure. The lapse damping method implemented in the second article can be used to partially delay the initial collapse of the gauge, which can allow the star to fully settle to a stable state. While it wasn't designed for this whatsoever, it does appear to accidentally work well

<iframe width="560" height="315" src="https://www.youtube.com/embed/81lubH4l3-M?si=mdrF9Um59VbhmkIT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

The star does eventually settle to a completely stable form, with no further evolution of any fields. Because of this problem, I've also found that the simulation is more robust when the initial conditions are set to $\alpha = 1$, as $\partial_i \alpha = 0$

#### Gauge damping

:(

## Testing

Do: Spin test

## Its hard to see the spinning

Advecting arbitrary scalar fields

## Merger

## papers

Analytic: https://www.aanda.org/articles/aa/pdf/2010/06/aa12738-09.pdf

Numerical: https://arxiv.org/pdf/1606.04881

Useful ref: https://arxiv.org/pdf/gr-qc/0403029

Today

## Approximating TOV

For $\Gamma=2$, there are approximations that can be used from eg [here (page 3)](https://www.aanda.org/articles/aa/pdf/2010/06/aa12738-09.pdf). I actually used this one for a while, and would highly recommend it if you don't want to solve TOV yourself

## I think there's an error in one of the equations

I'm 80% sure that (82) is incorrect, and that the leading factor of $2 \pi$ should be $4 \pi$. It gives exactly half the expected ADM mass for me

## Appendix


$F^n$ is actually an integral in time, ie its meant to be the total movement of material though the cell boundary between steps: $n$ and $n+1$:

$$F^n_{i - 1/2} = \frac{1}{\Delta t} \int^{t_{n+1}}_{t_n} f(q(x_{i-1/2}, t)) dt $$

This equation may be falling out of a specific approximation - I'll hold my hands up here and say I'm not incredibly sure

https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf 4.5
