---
layout: post
title:  "Numerical Relativity 105: Smashing neutron stars together like its 2002"
date:   2026-02-02 12:33:23 +0000
categories: C++
published: false
---

Hi!

\<iframe width="560" height="315" src="https://www.youtube.com/embed/rw9mKFwo4Ds?si=XAcRtXyLKmMBpL_x" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Its finally time to do something truly spectacular, and smash some neutron stars together. We'll be discussing how relativistic hydrodynamics works, how it compares to regular hydrodynamics, and some of the various approaches present in the literature. I've also extensively documented a lot of the issues you'll run into in practice if you try and implement this kind of thing

If you're here simply for the montage of black holes eating neutron stars: good news, there's a compilation at the end of this article

But first up: Some background

# What is hydrodynamics?

If you're like me, at some point you might not even really have known why hydrodynamics is a separate area of inquiry to just solving PDEs in general. Or, you might just think its an umbrella term for people who apply the same techniques we've been using already, but simply to fluids

This is incorrect. A fair chunk of this article is going to be explaining what hydrodynamics is, why we need to use different solving methods, and how that fits into general relativity. A lot of programmers' experience of fluid dynamics is the incompressible Navier-Stokes equations, so you might be wondering how similar that it is to what we're trying to do today (disclaimer: not very)

So today's article is going to contain a fair bit of information about regular hydrodynamics

## Hydrodynamic Formalisms

There are three primary kinds of hydrodynamic formalisms:

1. Lagrangian. This involves tracking particles around your space, and figuring out what properties a fluid derived from those particles would have
2. Semi Lagrangian. This is what most programmers are familiar with - you have grid cells, and trace your velocity backward through the grid to find out where your fluid originated from
3. Eularian. Here, we have grid cells, and the velocity is estimated from the derivatives of those grid cells

Today we'll be using a purely Eularian scheme. We'll get to the differences between the hydrodynamic techniques for solving Eularian equations, and regular PDE solving, after we get to the relativistic portions of this article. There are a bunch of other techniques as well like lattice Boltzmann if you're interested, this is just the major schemes

# Relativistic Eularian Hydrodynamics - 2002 style

We're going to be looking at two papers today, primarily the latter:

[Fully general relativistic simulation of coalescing binary neutron stars: Preparatory tests](https://arxiv.org/pdf/gr-qc/9908027)

[Hydrodynamic Simulations in 3+1 General Relativity](https://arxiv.org/pdf/gr-qc/0209102)

Note that there was a significant shift in approach from the first paper, to the second, and we'll be using the second's notation and equations. In this approach, we have the following variables for our fluid dynamics:

|Notation | What does it represent |
|-|-|
|$\rho_*$| Rest mass |
|$e_*$| Energy |
|$\tilde{S}_k$ | Momentum (ish) |

This is what we'll be evolving directly. I've also translated the paper's old-style conformal factor $\phi$, into our newer conformal factor $W$. A table of conversions is provided at the end of this article for convenience

We have the following definitions:

|Variable |Definition | Notes |
|-|-|-|
|$\rho_*$ | $\rho_0 \alpha u^0 W^{-3} $ | Rest mass |
|$e_*$ | $(\rho_0 \epsilon)^\frac{1}{\Gamma} \alpha u^0 W^{-3}$ | Unclear how a numerical equation of state would work, or if a varying $\Gamma$ is valid. Represents energy |
|$\tilde{S}_k$ | $\rho_* h u_k$ | Some kind of momentum term |
| $h$ | $1 + \epsilon + \frac{P}{\rho_0}$ | $1 + \Gamma \epsilon$ with the perfect fluid equation of state, $P = (\Gamma - 1) \rho_0 \epsilon$ |
|$w$ | $\rho_* \alpha u^0$ | Must be calculated via an iterative procedure |
|$v^i$ | $\frac{u^i}{u^0}$ | Represents a coordinate velocity |

The notation in this article is harmonised with the previous one. $\rho_0$ is the rest-mass density, $\epsilon$ is the specific energy density, $u^0$ is the lorentz factor, and $\alpha$ is the lapse. I also won't be fighting with the paper, and we'll be using a $\Gamma = 2$ perfect fluid equation of state - because its unclear how a numerical one would work here

## Initialising our variables

At the end of the previous article, we ended up with our fluid quantities: $\rho_0$, $\epsilon$, $u^i$, and $u^0$

There are two pitfall traps here:

1. The initial procedure we used last time appears to have assumed implicitly that $\alpha = 1$, and $\beta^i = 0$ - so use these when initialising regardless of what you actually pick for them
2. $u_i = \beta^i u^0 + \gamma_{ik} u^k$. If you want to prove this, calculate $u_i = g_{i\nu} u^\nu$. There's maths in the appendix

We can now carry on immediately from our last article, which follows on as such:

```c++
valuef pressure = mu_to_P(mu);
valuef p0 = pressure_to_p0(pressure);

valuef epsilon = (mu / p0) - 1;

//with raised index
v3f ui = Si / ((mu + pressure) * u0);

valuef gA = 1;
v3f gB = {0,0,0};

valuef p_star = p0 * gA * u0 * pow(cW, -3);
valuef e_star = pow(p0 * epsilon, (1/Gamma)) * gA * u0 * pow(cW, -3);

v3f u_i;

for(int i=0; i < 3; i++)
{
    valuef sum = 0;

    for(int k=0; k < 3; k++)
    {
        sum += Yij[i, k] * ui[k];
    }

    u_i[i] = gB[i] * u0 + sum;
}

valuef h = calculate_h_from_epsilon(epsilon);

v3f Si_lo_cfl = p_star * h * u_i;

as_ref(hydro.p_star[pos, dim]) = p_star;
as_ref(hydro.e_star[pos, dim]) = e_star;
as_ref(hydro.Si[0][pos, dim]) = Si_lo_cfl[0];
as_ref(hydro.Si[1][pos, dim]) = Si_lo_cfl[1];
as_ref(hydro.Si[2][pos, dim]) = Si_lo_cfl[2];
```

Where:

```c++
valuef calculate_h_from_epsilon(valuef epsilon)
{
    return 1 + get_Gamma() * epsilon;
}
```

That's it, no other surprises

## Evolution equations

So far, so good. Lets look into the basic set of evolution equations [(26-28)](https://arxiv.org/pdf/gr-qc/0209102):

$$\begin{align}
\partial_t \rho_* + \partial_i(\rho_* v^i) &= 0\\
\partial_t e_* + \partial_i(e_* v^i) &= 0\\
\partial_t \tilde{S}_k + \partial_i(\tilde{S}_k v^i) &=
                       - \alpha \frac{1}{W^3} \partial_k P - w h \partial_k \alpha \\
                       &-\tilde{S}_j \partial_k \beta^j + \frac{\alpha W^2\tilde{S}_i \tilde{S}_j}{2wh} \partial_k \tilde{\gamma}^{ij}\\
                       &+ \frac{\alpha h(w^2 - p_*^2)}{w} \frac{\partial_k W}{W}
\end{align}
$$

### The reason why hydrodynamics is a thing

We'll get around to some implementing soon. But first: lets talk about these equations in a generic form:

$$\begin{align}
\partial_t \rho_* &+ \nabla  (\rho_* \textbf{v}) = 0\\
\partial_t e_* &+ \nabla  (e_* \textbf{v}) = 0\\
\partial_t \tilde{S}_k &+ \nabla  (\tilde{S}_k \textbf{v}) = \mathrm{Source}\\
\end{align}$$

Or more generally:

$$
\partial_t q + \nabla (q \textbf{v}) = \mathrm{Source}
$$

This is the standard representation in hydrodynamics of advection equations, with the right hand side being called a source term (which you shouldn't confuse with an ADM source term). In general, the source terms are split out, and no special treatment is given to their solving[^solving], so we're going to now unceremoniously ignore them

[^solving]: We'll just be literally adding them afterwards

In hydrodynamics there are things called *conserved quantities* - like rest mass, energy, and momentum for a fluid dynamics simulation. The idea behind a conserved quantity is that we want it to be conserved (unsurprisingly), eg a good simulation should keep the total rest mass exact

Naively, you might think to discretise $\partial_i(p_* v^i)$ as something like this, like all our other derivatives:

```c++
auto do_p_star = [&](valuef p_star, v3f v, int i) {
    return diff1(p_star * v[i], i, d);
};

valuef sum = 0;

for(int i=0; i < 3; i++) {
    sum += do_p_star(p_star, v, i);
}
```

This kind of discretisation makes no guarantees about conservation. While it will work, in general the hydro people will start to frown their eyebrows off, and your simulation will be physically very suspect. What's the alternative?

# Hydrodynamics 101: A crash course

This is one of the few times we'll be chatting about something which isn't directly general relativity, which puts this outside my expertise. If you do hydrodynamics, know cool things about fancy high resolution schemes, or spot any mistakes here: please get in touch[^anything]

[^anything]: In general, I'll implement anything I can get my hands on which has a complete set of equations for it. This article is explicitly intended to give people who know hydrodynamics, but not GR, enough room to work with to say "aha, I know how to solve that kind of equation!"

Eularian hydrodynamics in general is concerned with solving a slightly more general set of equations of the form:

$$\partial_t q + \nabla f(q) = \mathrm{Source}$$

This is generally[^generally] broken up into three 1D problems (which are summed). For us, this is:

[^generally]: We're using an 'unsplit' scheme where you just sum the individual problems. There are other ways of doing this, eg one dimension at a time

$$\partial_t q + \partial_x (q v_x) = \mathrm{Source}$$

Good techniques for solving this have the following properties:

1. They conserve the quantity $q$
2. They handle 'shocks', ie discontinuities in $q$
3. They don't produce oscillations that build up and cause everything to break

These are expressed as more technical requirements:

| Term | Meaning|
|-|-|
| Finite Volume | A specific technique for guaranteeing conservation |
| Shock capturing | Everything doesn't blow up when there are discontinuities in $q$, like significant pressure changes |
| Total Variation Dimishing (TVD) | The discretisation method doesn't produce increasing oscillations near discontinuities |
| High resolution | Has a spatial convergence order of 2+ in smooth parts of the solution. Currently, we're a 4th order NR sim |

In numerical relativity, 'shocks' are partially handled via Kreiss-Oliger dissipation[^ramble] - but the equations don't tend to produce the kinds of errors you can get with hydrodynamics. Kreiss-Oliger isn't really appropriate to hydrodynamics, as it won't conserve our variables

[^ramble]: Kreiss-Oliger dissipation is only intended to handle problems that build up as a result of finite difference truncation errors. These can cause oscillations. It is however implicitly - perhaps unintentionally - used to smooth the grid in general. Particularly, singularities (being a discontinuity, ie a shock) are smoothed out by Kreiss-Oliger, which damps it. I don't know that this multipurpose function of Kreiss-Oliger is strictly intended, but it appears to be common. Shocks in NR also appear to be uncommon in practice, whereas they are very common in fluid dynamics necessitating different solving techniques

[Appendix A](https://arxiv.org/pdf/gr-qc/0209102) in the paper we're looking at describes a hydro treatment: but as far as I can tell, the description is significantly incomplete. We're going to have to come up with something different, which means: learning

## Conservative discretisation

The basic form of these discretisations is as follows. First off, we define a *flux* as the following quantity:

$$f_i = v_i q_i$$

$_i$ is a grid cell offset - I'm not going to try and fight hydro notation, its just going to clash terribly with tensor index notation and we'll live with it. The conservative discretisation scheme is then as follows ([4.4](https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf) or [4.9](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf)):

$$\partial_t q = \frac{1}{\Delta x} (F^n_{i-\frac{1}{2}} - F^n_{i+\frac{1}{2}})$$

where $\Delta x$ is the scale. This is the flux conserving form, and is generic across any hydrodynamics scheme. Solving for the half grid cell flux at the boundary between our grid cells is the joy of hydrodynamics

High resolution schemes often mix and match between different orders in different smoothness areas - having a lower order in less smooth areas. There's some interesting [theoretical reasons](https://en.wikipedia.org/wiki/Godunov%27s_theorem) as to why

I'm not going to attempt to document hydrodynamics in general here, so its time to look at a specific form of solving this equation. It fulfills all the requirements for a 'good' technique, as well as the major requirement which is having a workable set of equations that I can implement[^implement]

[^implement]: Going for a dig through the hydrodynamics literature is surprising. Every field develops its own notation and language, and hydrodynamics appears to have developed its own convention for which steps are omitted when describing a particular scheme. Finding documentation on those omitted steps is surprisingly challenging. That's the core reason why these articles come with a working, testable implementation that you can dig through, and why code often makes much better documentation than papers in my experience

https://www.astro.uzh.ch/~stadel/lib/exe/fetch.php?media=spin:compastro_godunov.pdf todo: contains a note on flux

## A specific scheme: MUSCL

This scheme uses a limiter function to smoothly swap between first order and second order. As the fluid *gradient* gets too high, the scheme decays to first order[^notes]. Different limiters have different properties - some introduce lots of diffusion, some accidentally introduce oscillations. The most common, least diffusive, non broken limiter appears to be known as 'superbee', which we'll be using

[^notes]: This is one of the reasons why higher order fluid simulations are less useful than they might appear. High order in smooth areas only is all well and good, but that's also precisely where we need the least resolution

These limited functions then have upwinding applied to them, to result in a stable scheme. On a technical note, this upwinding is actually a solution to the [Riemann problem](https://en.wikipedia.org/wiki/Riemann_problem) - which works because of the simple advection we're solving for. There's some good notes over [here](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2009/Chapter_6.pdf)

There's two different forms of these equations, slope limited, and flux limited. A good explicit reference is [here](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf)

### Slope limited

[4.33](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf)

$$
F^n_{i - \frac{1}{2}} =
\begin{cases}
\begin{align}
&v_{i - \frac{1}{2}} q_{i - 1} + \frac{1}{2} v_{i - \frac{1}{2}} (\Delta x - v_{i - \frac{1}{2}} \Delta t) \sigma_{i-1}  \;\; &\mathrm{if}\;\; v_{i - \frac{1}{2}} >= 0 \\
&v_{i - \frac{1}{2}} q_{i} - \frac{1}{2} v_{i - \frac{1}{2}} (\Delta x + v_{i - \frac{1}{2}} \Delta t) \sigma_{i} \;\; &\mathrm{if}\;\; v_{i - \frac{1}{2}} <= 0 \\
\end{align}
\end{cases}
$$

$\sigma_i$ is a a slope limiter, see [4.4.2](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf) for examples

### Flux limited

[6.30](https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf) and [4.38](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf) are equivalent:

$$\begin{align}
F^n_{i - 1/2} &= v_{i - 1/2}^- q_i + v_{i - 1/2}^+ q_{i - 1} + \frac{1}{2} \mid v_{i - 1/2} \mid (1 - \mid \frac{v_{i - 1/2} \Delta t}{\Delta x} \mid) \delta_{i - 1/2}\\
\\
\delta_{i-1/2} &= \phi(\theta_{i - 1/2}) (q_i - q_{i - 1})\\
\bar{v}^+_{i-1/2} &= \mathrm{max}(v_{i-1/2}, 0)\\
\bar{v}^-_{i-1/2} &= \mathrm{min}(v_{i-1/2}, 0)\\
\end{align}
$$

Where [(4.37)](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf):

$$\theta_{i - 1/2} =
\begin{cases}
\begin{align}
\frac{q_{i - 1} - q_{i - 2}}{q_i - q_{i - 1}} \;\; &\mathrm{if} \;\; v_{i - 1/2} >= 0\\
\frac{q_{i + 1} - q_i}{q_i - q_{i - 1}} \;\; &\mathrm{if} \;\; v_{i - 1/2} <= 0 \\
\end{align}
\end{cases}
$$

$\phi$ is a *flux* limiter. There's nothing fundamentally that different here to the slope limiting equations - this form seems to be largely to avoid the selection operator that you see in the slope limited version. We'll be using the superbee limiter:

$$\phi(r) = \mathrm{max}(0, \mathrm{min}(1, 2r), \mathrm{min}(2, r))$$

The calculation for $F^n_{i + 1/2} $ is identical, just with $i$ incremented

## The half velocity

There are two ways that I've seen to calculate this half velocity:

1. $v^{n}_{i - 1/2} = \frac{v^{n}_{i} + v^{n}_{i - 1}}{2}$
2. $v^{n}_{i - 1/2} = \frac{\rho_{*i} v_i + \rho_{*i-1} v_{i-1}}{\rho_{*i} + \rho_{*i-1}}$

$\rho_*$ is our rest mass. I've also tested a second order interpolation:

$$v^{n}_{i - 1/2} = -0.0625 v^n_{i - 2} + 0.5625 v^n_{i - 1}+ 0.5625 v^n_i - 0.0625 v^n_{i + 1}$$

In general, these options seem to be fairly identical, so you may as well use the first. I've been using the second purely for commonality with the referenced paper

If you're wondering why we don't just reconstruct the flux directly, and limit that without using a half velocity at all: The answer seems to be because of the upwinding scheme. If you try and approach it like this, the reconstructed flux's velocity, and the velocity you use to toggle the upwind direction will differ - which leads to an incorrect solution - I think

More advanced solvers use a Riemann solver, but this requires more information like Eigenvectors. I'll probably get around to this in the future

## 2002 Relativistic hydrodynamics - specifically

In theory, the hydrodynamics portion of this article is now done

Here's where there's a small problem: Despite our equations looking like a conservative hydrodynamics equation, they actually are not in this formalism. While I believe that $\rho_*$ *is* in conservative form, $e_*$ is not and is not a conserved quantity across shocks - so we'll have to artificially dissipate them despite using a shock capturing formalism. I have absolutely no idea about $\tilde{S}_k$

In general, this is one of the reasons why this formalism was ditched - more modern formalisms are expressed purely in terms of conserved quantities, which makes their hydro treatment more theoretically rigorous

# Evolution Equations

With that, we can implement the above scheme for all the $\partial_i(q v^i)$ terms, which works great. You can just add the source terms on afterwards, and sum each different direction for the hydro scheme (this is technically an 'unsplit' method)

There's two other nontrivial terms to talk about now: $v^i$ and $w$

## $v^i$

The quantity $v^i$ is as follows:

$$v^i = -\beta^i + \frac{W^2 \alpha \tilde{\gamma}^{ij} \tilde{S}_j}{w h}$$

Todo: migrate to the end

This can either be worked out from [2.12](https://arxiv.org/pdf/gr-qc/9908027) and converting their variables, or by calculating:

$$
\begin{align}
u_k &= \frac{\tilde{S}_k}{p_* h}\\
u^i &= g^{i\nu} u_{\nu}\\
v^i &= \frac{u^i}{u^0}
\end{align}
$$

You'll also have to work out the quantity $u_0$ if you're deriving this by hand. Todo: Do this at the end of the article

## $w$

This quantity is much less fun. It has the following form (29):

$$w^2 = p_*^2+ W^2 \tilde{\gamma}^{ij}\tilde{S}_i \tilde{S}_j \left[1 + \frac{\Gamma e_*^{\Gamma}}{p_*(w \frac{e^{6\phi}}{p_*})^{\Gamma-1}} \right]^{-2}$$

There are two problems:

1. There is no analytic solution
2. It divides by zero a fair bit

We can solve #1 by using fixed point iteration with the initial guess $w=\rho_*$ as this is a lorentz factor multiplied by density terms. Simply plug in your guess into the right hand side, calculate the new value of $w$, and rinse and repeat. #2 is more of a pain

The way this equation is structured out of the box is slightly cursed. Lets rearrange it a bit:

$$\begin{align}
A &= (W^3)^{\Gamma-1}\\
D &= \frac{w^{\Gamma-1}}{w^{\Gamma-1} + A \Gamma e_*^{\Gamma} p_*^{\Gamma-2}}\\
w^2 &= p_*^2 + W^2 \tilde{\gamma}^{ij} \tilde{S}_i \tilde{S}_j D^2\\
\end{align}
$$

The singular part is the divisor of $D$, and to fix it you can simply clamp the bottom to a small constant. We'll be getting back to the singular division issue later, as we'll be handling it systematically

Its worth noting here that when $\Gamma = 2$, the factor of $\rho_*$ drops out in $D$

## Recovering the primitive variables

$\rho_0$ and $\epsilon$ are called the primitive hydrodynamic variables, and recovering them requires $w$. Once you have that, you can calculate:

$$\begin{align}
\rho_0 &= \frac{W^3 p_*^2}{w}\\
\epsilon &= e_*^\Gamma p_*^{\Gamma - 2} (\frac{W^3}{w})^{\Gamma - 1}
\end{align}
$$

In general, its a good idea to avoid calculating $\rho_0$ if possible, as calculating $p_*^2$ is numerically suspect with small quantities. Some usefully optimised quantities are:

$$\begin{align}
\rho_0 \epsilon &= \left (e_* W^3 \frac{p_*}{w} \right)^\Gamma\\
h &= 1 + \Gamma \epsilon
\end{align}
$$

## ADM Source terms

The way matter integrates into the BSSN equations is via something known as source terms. These make up the components of the stress energy tensor (which up until now, has been 0), which are fed into our BSSN/ADM equations to make matter work

There are four standard ADM source terms:

$$\begin{align}
\rho_H &= h w W^3 - P\\
S_i &= W^3\tilde{S}_i\\
S_{ij} &= \frac{W^3}{wh}\tilde{S}_i \tilde{S}_j + P \gamma_{ij}\\
S &= \gamma^{ij} S_{ij} = W^2 \tilde{\gamma}^{ij} S_{ij} \\
\end{align}$$

There's a minor problem: $S_{ij}$ is singular at the singularity. The issue is that $\gamma_{ij}$ is undefined

Luckily, we can skip to the future, and discover that the form of our $S_{ij}$ source term is actually: $-W^2 8 \pi \alpha S_{ij}$[^alttechnique]. Given that $$W^2 \gamma_{ij} = \tilde{\gamma}_{ij}$$, we can instead re-format our equations like this:

[^alttechnique]: Calculating the pressure involves calculating the quantity $\rho_0 \epsilon$: we could scavenge one of the $W^2$ terms from that calculation to instead remove the $\gamma_{ij}$ term. However, the construction presented is a slightly more general approach that we can use in other methods, rather than relying on the *specific* form of the source terms, so we'll stick with it

$$
\begin{align}
\tilde{S}_{ij} &= \frac{W^5}{wh} \tilde{S}_i \tilde{S}_j + P \tilde{\gamma}_{ij}\\
S &=\tilde{\gamma}^{ij} \tilde{S}_{ij} \\
\end{align}
$$

We'll have to modify our BSSN source term to match the absorbed $W^2$ term (ie $-8 \pi \alpha S_{ij}$), but now our source terms become regular at the metric tensor. This is a minor improvement over the standard arrangement

## The BSSN equations

The additions are straightforward:

$$\begin{align}
\partial_t K &\mathrel{+}= 4 \pi \alpha (S + \rho_H)\\
\partial_t \tilde{A}_{ij} &\mathrel{+}= -8 \pi \alpha \tilde{S}_{ij}^{TF}\\
\partial_t \tilde{\Gamma}^i &\mathrel{+}= -16 \pi \alpha \tilde{\gamma}^{ij} S_j\\
\mathcal{H} &\mathrel{+}= -16 \pi \rho_H\\
\mathcal{M}_i &\mathrel{+}= -8 \pi S_i\\
\end{align}$$

The source terms conspire very conveniently to avoid having to calculate infinite quantities at the singularity which is great. The only infinities we have to worry about are in the actual hydrodynamic evolution equations themselves

# Artificial Viscosity

One of the big problems with our equations is that they actually aren't conservative: one key thing is that $e^*$ isn't actually conserved in the presence of shocks. To combat this, this scheme introduces a small amount of artificial viscosity to dissipate shocks away

A lot of papers here are quite vague as to how exactly to modify the viscosity. A complete description of this scheme requires us to go all the way back to [1984](https://adsabs.harvard.edu/full/1984ApJS...55..211H), where the extra viscous pressure is called $Q$. This is used in two places:

1. It is added to the pressure on the right hand side of $\partial_t \tilde{S}_k$, ie $\partial_k (P + Q)$
2. We have a new rhs for $e^*$, which we'll get into shortly

There are two complementary ways to calculate this additional pressure term $Q$

1. Quadratic viscosity
2. Linear viscosity

You can sum these

## Quadratic Viscosity

$$\begin{align}
Q_{Qvis} =
\begin{cases}
C_{Qvis}A(\delta v)^2\;\;&\mathrm{for} \;\delta v < 0\\
0 \; &\mathrm{otherwise}
\end{cases}
\end{align}$$

Where:

$$\begin{align}
A &= e_*^\Gamma (W^3)^{\Gamma-1} \frac{p_*^{\Gamma-1}}{w^{\Gamma-1}}\\
\delta v &= 2 \partial_k v^k \Delta h
\end{align}$$

And $$\Delta h$$ is the scale. $C_{Qvis}$ is a damping constant, which I set to $0.1$, and this paper recommends the range $[0.1, 1]$

Quadratic viscosity is generally left on throughout a simulation, but is disabled near a singularity. In theory, you could probably derive the strength of the quadratic viscosity from a hydrodynamic smoothness estimate to enable dissipation in unsmooth parts of the solution, but I have no information on if that's worthwhile

## Linear viscosity

$$\begin{align}
Q_{Lvis} =
\begin{cases}
-C_{Lvis}\sqrt{(\Gamma/n) p_* A}\;\;&\mathrm{for} \;\delta v < 0\\
0 \; &\mathrm{otherwise}
\end{cases}
\end{align}$$

$C_{Lvis}$ is a damping constant in the range $[0, 1]$. In my case, I set this damping constant as follows:

$$C_{Lvis} = e^{-\frac{t^2}{2 T^2}}$$

$T$ is a constant that represents a damping timescale for the linear viscosity, as it is generally only useful in the early parts of the simulation to iron out the star's oscillations. Leaving it on too long will result in a loss of velocity, and $T=200$ seems to work well

I don't have a clue what $n$ is and have never been able to find a single shred of discussion on what it represents, so I set it to $1$

Without linear viscosity:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/2oUI7VQ8aN0?si=nyjyIqzv1RC0tcEC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

With linear viscosity:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/YS4AoDqNOe4?si=4NY-GpvEqy2VY9zh" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Viscosity $e_*$

When using viscosity, you have to modify the evolution equation of $e_*$. The term to add is:

$$\partial_t e_* += -(\rho_0 \epsilon)^{(-1 + \frac{1}{\Gamma})} \;\; \frac{Q}{\Gamma} \; \partial_k (w W^{-3} v^k p_*^{-1})$$

## Viscosity conclusion

In general, linear viscosity is good for large scale damping and significantly improves the simulations stability. Our initial conditions are quite approximate and the stars relax into their final form, so damping this initial relaxation improves the simulation a lot, and produces stable non oscillating neutron stars. Quadratic viscosity is less applicable, as shocks aren't common in these simulations and so it seems to have relatively minimal effect

The viscosity scheme documented in this paper is actually not consistent - its an ad-hoc modification to fix up shocks. There is, in theory, a full hydro formalism which includes a consistent treatment of viscosity which works for ultrarelativistic matter - but unfortunately its behind a paywall Todo, link

## Final equation set

$$\begin{align}
\partial_t \rho_* + \partial_i(\rho_* v^i) &= 0\\
\partial_t e_* + \partial_i(e_* v^i) &= -(\rho_0 \epsilon)^{(-1 + \frac{1}{\Gamma})} \;\; \frac{Q}{\Gamma} \; \partial_k (w W^{-3} v^k p_*^{-1})\\
\partial_t \tilde{S}_k + \partial_i(\tilde{S}_k v^i) &=
                       - \alpha \frac{1}{W^3} \partial_k (P + Q) - w h \partial_k \alpha \\
                       &-\tilde{S}_j \partial_k \beta^j + \frac{\alpha W^2\tilde{S}_i \tilde{S}_j}{2wh} \partial_k \tilde{\gamma}^{ij}\\
                       &+ \frac{\alpha h(w^2 - p_*^2)}{w} \frac{\partial_k W}{W}
\end{align}
$$

# Relativistic Hydrodynamics Discussion

Before we get to the results, and overall discussion, its worth talking about this hydro formalism a bit more critically. Digging into a past project again equipped with much more knowledge and a critical eye was absolutely fascinating, and I learnt a lot about hydrodynamics along the way

The formalism I'm talking about today was relatively quickly abandoned in favour of a different approach, which I'll very likely get around to implementing in the near future. All the actual hard parts are done, so plugging in a new formalism is relatively straightforward (though we'll need a Riemann solver for reals)

As far as I can tell, there's the following issues with this approach:

1. The non atmospheric approach's conservation is heavily dependent on our minimum value of $\rho_*$, which has to be higher than i would like due to floating point imprecision. There's a mass loss of a few % with safe bounds
2. When $\rho_*$ is of the same order of magnitude as $\rho_{min}$, you have to be extremely careful with floating point accuracy. There's a significant amount of error due to precision issues, and some quantities are very poorly behaved
3. The non conservative nature of the equations means that conventional hydrodynamic solutions only have limited applicability
4. The mass-shell-drift problem, although I think that may be a problem with the specific implementation
5. Significant ambiguities exist with how to implement the equations numerically
6. The viscosity treatment is ad-hoc
7. Its unclear how to use a numerical equation of state here
8. There isn't much literature on this formalism

This - in theory - would all be solved by a newer formalism. This formalism isn't 'bad' however, and it seems to work. It makes for an extremely interesting test-case on modern hardware compared to what they could get away with in 2002

Another thing to add is: We're using an implicit scheme for both the BSSN equations, and the hydrodynamic equations. Simulating the hydrodynamic equations has fairly low performance overhead - which means that we should be able to get away with a *much* more expensive formalism for all of the hydrodynamics in this article. Some kind of super duper high resolution predictor-corrector scheme would likely work extremely well, which I'll do as soon as I can find one

# Testing

## Stationary tests

In our last article, we had these test cases:

| Case | $\rho_c$ | $K$ | $\Gamma$ | Expected $M$ | Expected $R$ |
|-|-|-|-|-|-|
| [C1](https://arxiv.org/pdf/1606.04881) (section VII) | $6.235 \times 10^{17}\; \mathrm{kg}\;\mathrm{m}^{-3}$ |  $123.641 M_{\odot}^2$ where $c=G=1$ | $2$ |$1.543 M_\odot$ | $13.4 \; \mathrm{km}$ where $c=G=1$ in Isotropic coordinates |
| [C2](https://einsteintoolkit.org/thornguide/EinsteinInitialData/TOVSolver/documentation.html) (see after interior) | $1.28 \times 10^{-3} \; \mathrm{m^{-2}}$ where $c=G=M_{\odot} = 1$ | $100$ where $c=G=M_{\odot} = 1$ | $2$ | $1.4 M_{\odot}$ | $14.15\; \mathrm{km}$ where $c=G=1$ in Schwarzschild coordinates |
| [C3](https://arxiv.org/pdf/gr-qc/0110047) (see: C) | $8.0 \times 10^{-3}$ where $c=G=M_{\odot}=1$ | $100$ where $c=G=M_{\odot} = 1$ | $2$ | $1.447 M_{\odot}$ | unclear |

Test cases 1 and 2 work fine with no tweaks. Test case 3 is slightly more interesting: I didn't realise that it was specifically a test of unstable neutron stars migrating to a stable branch. According to the [original paper](https://arxiv.org/pdf/gr-qc/0110047), oscillations introduced by finite difference errors cause a pertubation which either causes it to grow to a regular neutron star, or collapse to a black hole

In our case, it collapses to a black hole[^discussion]:

[^discussion]: While the TOV code produces the exact correct rest mass of $M_0 = 1.535$, after the procedure to insert it into the simulation and correct for the hamiltonian constraint, our rest mass is higher at $M_0 = ~1.54$. It isn't a case of the laplacian solving step being incorrect, and may be a feature of our relatively small simulation area + close in boundary condition leading to a slight error for the rest mass. I had to shrink the simulation area to get enough resolution to successfully resolve the black hole while not dying of old age

\<iframe width="560" height="315" src="https://www.youtube.com/embed/VGyCgomuJgE?si=BJ3zIEg7JGg7u8SF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

\<iframe width="560" height="315" src="https://www.youtube.com/embed/HgsTbPsNP3M?si=hkZ9mB7ZtAmrcM2S" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

\<iframe width="560" height="315" src="https://www.youtube.com/embed/YCckygeH9II?si=rlbwZtzFdaera0nI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Stationary Spinning Test

This is test case C1, with dimensionless spin $\chi = 0.5$:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/nl-IWvttSnA?si=Dq3FLCIOrglz2FnI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Now.. while its clear that a spinning neutron star is a lot more wobbly than a regular neutron star, its very hard to tell if its actually spinning or not

### Advecting arbitrary fields

This step is more for fun. Lets define an initial colour distribution ${r, g, b}$, and map it to our star's density as follows:

$$\begin{align}
r_* &= r \rho_* \\
g_* &= g \rho_* \\
b_* &= b \rho_* \\
\end{align}
$$

Then, we can advect our $\mathrm{rgb}_*$ quantities using the advection equation, ie:

$$\partial_t r_* = -\partial_i (r_* v^i)$$

Creating an arbitrary[^arbitrary] initial colour distribution can be done either as a function, or if you're willing to put an absolutely cat-astrophic amount of implementation work in: as a texture

[^arbitrary]: I don't *think* an arbitrary colour distribution actually reproduces $\rho_*$ and the correct motion of an advected quantity, so its good to treat this as illustrative of the velocity flow

\<iframe width="560" height="315" src="https://www.youtube.com/embed/5pi4XzE-keE?si=UekikwPEgi_n3mCy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

I genuinely have no idea why I spent so much time implementing this[^fishies], and you absolutely shouldn't do this. Here's a less memey look at the spinning:

[^fishies]: This is an accurate depicion of my brain's internal task prioritisation process: \<iframe width="560" height="315" src="https://www.youtube.com/embed/RR-g4vuCtog?si=bNlOPuKV1oAUzojx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

\<iframe width="560" height="315" src="https://www.youtube.com/embed/-iemn0MzBQk?si=1kRiyzRPGYZksiDh" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

You can see that the star settles into a stable oblate shape (or at least, stable enough). This test uses a much longer linear viscosity timescale of $T=800$. The grid resolution for all tests is $199^3$

# Inspiral

Finding good test cases is tricky. It seems that the literature around neutron stars isn't quite as explicit with the initial conditions and testable results as it is for black holes, so there's often quantities which are left unspecified. It seems that a particular initial conditions solver is widely used, and so people just use that and don't necessarily specify everything else explicitly

Here's two ad-hoc test cases:

| Name | $\rho_c$ | $K$ | $\Gamma$ | Central Separation ($\mathrm{km}$) | Linear momentum | $\chi$ (dimensionless spin) | $N$ (gauge damping) |
|-|-|-|-|-|-|-|-|
|I1, Similar to [A.](https://arxiv.org/pdf/1606.04881) | $6.235 \times 10^{17} \; \mathrm{kg}\;{m^{-3}}$| $123.641$ | $2$ | $54.6 \mathrm{km}$ | $\pm 0.25$ | $0$ | $0.2$ |
|I2| $3.235 \times 10^{17} \; \mathrm{kg}\;{m^{-3}}$| $123.641$ | $2$ | $54.6 \mathrm{km}$ | $\pm 0.14$ | $0.25$, perpendicular to the orbital plane (and cospinning) | $0.05$ |

Where $\chi = \frac{J_{adm}}{M_{adm}^2}$

These look like this:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/VYmEpiLY_hY?si=FyXcn08-O4ObLkYT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

\<iframe width="560" height="315" src="https://www.youtube.com/embed/HKB8THFWLdk?si=Y60LwVSLNBqLrmGq" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

This isn't terribly scientific, though it confirms that everything doesn't look like complete nonsense. Ideally we'd have an initial condition with all fixed parameters and rigorously check our results, but its very common for initial conditions to be derived from post newtonian data, or from an energy minimisation criteria, which leaves these parameters implicit

Case $\Gamma^{--}_{050}$ [has the following parameters](https://arxiv.org/pdf/1311.4443)

| $\rho_c$ | $K$ | $\Gamma$ | Central Separation | Linear momentum | $\chi$ | $N$ | Notes |
|-|-|-|-|-|-|-|-|
|$0.000960296$ | $123.6489$ | $2$ | $59 \mathrm{km}$ | Unspecified, $\approx \pm 0.24$ | $-0.0499$ | $0.2$ | The spin direction is *against* the orbital direction |

Which gives this:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/czDYhdyuMO0?si=YodMhX4B9llOyX6L" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Without an exact value for linear momentum, we cannot precisely attempt to replicate the original paper, but we appear to get a reasonable inspiral. Its a little unsatisfying - I've been searching around for test cases which give exact values, but in general people tend to miss out one or more key parameters. Really though, within a few articles we'll be producing gravitational waves together, which is likely when I'll be investing in a post newtonian expansion + energy minimisation scheme, as that makes this very directly testable. This is a much better approach than trying to replicate things by staring at graphs in papers, because we can quantitively determine the accuracy then

With that significant caveat in mind, this scheme does appear to work. Exactly how energy conserving it is is up for grabs, but there's nothing obviously unphysical going on. The hamiltonian constraint errors appear to stay low and bounded which is great as well. More resolution or a coordinate transform would likely help here significantly too, but that's a topic for the future

# Performance

The performance is pretty good - at $199^3$ it takes 81 ms/tick with the hydro on, and ~69 ms/tick with it off. Some of that is because there's a few extra copies here and there, so I'd expect to be able to shave about 5ms off

The main overhead is actually the amount of extra buffers required. We have $5$ variable buffers, which we have to store $3$ copies of - and on top of that, for the Crank-Nicolson, there's another $5$ for the intermediate state (which could be eliminated). This limits the maximum resolution size quite significantly which is unfortunate

# Discussion

I've discussed the relativistic hydrodynamics formalism specifically in depth up above, so this is a general review of this project

Overall, this has gone pretty well. I'm not *super* jazzed at the lack of rigorous testing here, but this makes a very good stepping stone on the way to more advanced techniques and new ideas like post newtonian formalisms - so I think this is perfect as a hydro introduction. I'm also not super convinced on the actual hydrodynamics solver I've implemented - but hey that just means we've got more work ahead of us

We're really *really* pushing the limits of single precision with this technique as well, its right on the boundary of what is acceptable: if you're interested in novel precision techniques, like unums, or projective reals, this would be a great playground for you

In general though, I think this more than serves its purpose, which is to be a good base to build on. Which we absolutely will, soon

# Next time

The next article is going to be N-body particle dynamics, because I need to take a break from more serious articles like this, and go do something incredibly silly and fun. It'll be great!

# Montage

\<iframe width="560" height="315" src="https://www.youtube.com/embed/EMyjmlRYh-A?si=iuS68cJYS6TYVDxA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

This next one is a video of a failed test case:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/TrSo_bUgAvI?si=7U5arwIbMmY5Ib5W" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

This is before the scheme was conservative:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/EOQ4q_6Y3d0?si=RBNli4B3uUodnoz3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

This is painstakingly accurately rendered with redshift, and a 4d voxelisation. Its tricky to get good quality with this technique due to memory pressure, so I haven't shown it off here

\<iframe width="560" height="315" src="https://www.youtube.com/embed/ZT3COBsAXRE?si=LjI_co6PcNx5YGPq" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Basic head on collision:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/1obG7N9xIZ0?si=uQFtLE5StLanrx6V" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Binary black hole collision:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/WcBaiJHgyak?si=F5qwyMtoolM5GJi0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

# Appendix

$F^n$ is actually an integral in time, ie its meant to be the total movement of material though the cell boundary between steps: $n$ and $n+1$:

$$F^n_{i - 1/2} = \frac{1}{\Delta t} \int^{t_{n+1}}_{t_n} f(q(x_{i-1/2}, t)) dt $$

This equation may be falling out of a specific approximation - I'll hold my hands up here and say I'm not incredibly sure

https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf 4.5

## Conformal decomposition

The conformal decomposition is defined as follows: $$\tilde{\gamma}_{ij} = W^2 \gamma_{ij} = e^{-4\phi} \gamma_{ij}$$

|Ours|Theirs|
|-|-|
|$W$|$e^{-2\phi}$|
|$W^2$|$e^{-4\phi}$|
|$W^3$|$e^{-6\phi}$|
|$\frac{1}{W}$|$e^{2\phi}$|
|$\frac{1}{W^2}$|$e^{4\phi}$|
|$\frac{1}{W^3}$|$e^{6\phi}$|
|$-\frac{\partial_i W}{2W}$|$\partial_i \phi$|

This is basic, but it saves a lot of time looking things up when you check the reference paper

## BSSN Equations with source terms


# Implementation Details

There are a variety of implementation details that tend not to be discussed, that I will now dig into

## Divisions by zero

As you may have noticed, our equations involve quite a bit of dividing by zero. In general, there are many instances of divisions by $w$, or $W$, which we'll have to deal with

In general, this is pretty straightforward. For division by $W$, I clamp $W$ to $0.1$. This might seem quite large, but in general we don't really care about the hydrodynamics near the singularity of a black hole, and its more important for the equations to remain regular

For divisions by all other quantities, I use a division tolerance of $1e-7$, of the following form:

```c++
template<typename T>
auto safe_divide(const auto& top, const T& bottom, float tol = 1e-7f)
{
    valuef bsign = ternary(bottom >= 0, valuef(1.f), valuef(-1.f));

    return ternary(fabs(bottom) <= tol, top / (bsign * tol), top / bottom);
}
```

## Non atmospheric hydrodynamics

One of the key aspects of this paper is the non-atmospheric aspect of it. The idea here is that when $\rho_* < \rho_{min}$, you flush all your evolution variables to $0$ for a true vacuum. This leaves a few questions about exactly how and when to flush your evolution variables to zero

We're using a pretty different integration scheme (backwards Euler + Crank-Nicolson) compared to the paper. To take a pure backwards Euler scheme as an example, you may be tempted to flush variables to zero at the end of a backwards Euler substep - this is actually the wrong choice. Consider that the next backwards Euler iteration is calculated as:

$$next = base + f(in)$$

If our cell value is just below $\rho_{min}$, and our neighbours are above, in the next iteration there'll be effectively a hole in the simulation grid which fluid will rush into. Because $base$ is nonzero, this means that we'll end up with too much fluid in our current cell. This can cause an oscillatory behaviour which doesn't converge very well

Instead, I copy the current cell value over if $\rho_* < \rho_{min}$, and only perform a flush after the whole step is resolved

Because the amount of matter flushed to vaccum is proportional to the grid surface area of the star, there is a small loss of mass as the simulation progresses. This is unfortunate

## Operator Splitting

Our equations are of the form:

$$\partial_t q + \partial_i (q v^i) = \mathrm{Source}$$

Operator splitting means that you update all the advection terms first, and then evaluate all source terms post advection - which smells a bit like a backwards Euler step

I did some fairly extensive testing of various operator splitting methods vs treating these as regular evolution equations for this article, and was not able to find any stability difference at all. Operator splitting requires a few extra buffers for storage of intermediate variables, so in this case it was strictly worse. It may be because we're using an implicit scheme with much higher resolution

## Black Hole Collapse

Matter within a black hole in the set of equations I'm presenting here is only moderately badly behaved at the singularity, which is frankly incredible. You do need to do two things to make this work well:

1. Disable all viscosity in the vicinity of an event horizon
2. Dissipate all the matter fields to zero when within an event horizon

In general, the lapse $\alpha$ is a good surrogate variable for being near an event horizon. I use a conservative $0.45$ for disabling viscosity, and $0.15$ for dissipating matter fields. The latter constraint imposes a minimum simulation resolution to successfully simulate a black hole collapse, as the simulation will eventually fail if matter is not damped within an event horizon

## Boundaries

The Sommerfeld boundary conditions I find tend to be a bit unstable with matter. Simply damping the fields away to zero as they approach the boundary works very well. This means you can turn the usual radiative boundary condition off

## Kreiss-Oliger

Kreiss-Oliger is not applied to any fields as it would upset the conservation. The hydro scheme being TVD means that it is unnecessary. If you do not use a TVD hydro scheme, you'll want to switch Kreiss-Oliger on, with the obvious ramifications of non conservation of your quantities

## $e_*$ blows up

One documented consequence of the atmosphere-free formulation is that a thin (resolution dependent) shell of material drifts away from the star, and remains suspended around it. This thin shell in theory can end up superheating, causing unfun code times

This paper fixes it by clamping $$e_* = min(e_*, 10 \rho_*)$$. I do this when $\rho_* < 10\rho_{min}$

I haven't found this modification to be at all important in practice, so its disabled by default

## $v^i$'s vacuum boundary is inconsistent

This paper says that when the atmosphere is classed as a vacuum, $v^i = 0$. This is a *very* strange limit: we can see that our equation for $v^i$

$$v^i = -\beta^i + \frac{W^2 \alpha \tilde{\gamma}^{ij} \tilde{S}_j}{w h}$$

probably tends to $-\beta^i$ when $p^* = 0$, not $0$. I've included this as a configurable tweak in the code, and it does affect inspiral

Interestingly, the paper we're looking at uses a rotating coordinate frame, which is essentially a velocity applied to the gauge conditions initially (ie $\beta^i$). This possible limit error in combination with the rotating coordinate frame (which results in a strongly non zero $\beta^i$), could lead to a significant discontinuity in the velocity at the edge of the star. This may be the root cause behind this paper's thin shell of material drifting away from the surface, as a significant derivative in the velocity will be generated at the boundary which may fling material away

## Hamiltonian constraint damping

There are two new major features that I implemented since we last simulated black holes together:

1. Hamiltonian constraint damping
2. No constraint damping near the boundary

Both of these are quite important to reducing simulation errors. I use the following modification to $\partial_t W$:

$$\partial_t W \; \mathrel{+}= \; C \; \Delta t \;\alpha W \mathcal{H}$$

$C$ is a damping strength, set to $0.15$. It is $0$[^smooth] when the distance to the simulation's boundary is $<10$ in grid cells

[^smooth]: A smoother cutoff might further improve the boundary behaviour

1. The prefix term of $C \Delta t$ is derived from [this](https://arxiv.org/pdf/2404.01137) paper
2. We're using $\mathcal{H}_-$
3. The lapse (ie $\alpha$) term improves the behaviour of this modification for BBH collisions
4. The extra factor of $- W$ comes from transforming this modification from the $\phi$ conformal factor, to the $W$ conformal factor

The near-boundary modification has the effect of significantly reducing boundary constraint contamination of the simulation, compare below. Keep an eye on the top left box, which is the constraint error

No damping:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/PLMRsU3Qh9o?si=Rr1Ov4wnNXtrCtE7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Damping everywhere:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/MDc_y1IVKlU?si=5bc9qxm7iBCJIJcb" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Damping excludes boundary:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/doS85Mh78Vc?si=ylrxTYz_wWZ5oo5f" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Source terms

Todo: This is too long

Actually generating the stress energy tensor with its 10 components is a mistake - its much better to directly express the source terms from the underlying formalism, as it saves a huge amount of memory bandwidth. I rarely go into application-level architectural details because it normally isn't relevant, but this is the major exception

Implementing this correctly is extremely difficult to do in a standard programming language in a high performance way, because the BSSN equation implementation itself needs generic, direct access to whatever buffers can derive our source terms (including $w$)

Runtime branching is horrendously expensive here - as in the non hydro case we'll end up with a lot of extra instructions being generated which are unused. The limited instruction cache space is a strong performance bottleneck, as well as VGPR usage (which we push right up against) - and conditional memory accesses are always bad

This issue is actually the major reason which motivated the development of the generated language I use in these articles - as it allows you to generate different kernels depending on what features are enabled, while composing together all the individual sources via a plugin architecture. If you want good performance, I would highly recommend something similar - and a lot of development of this toolkit since the last article has been around getting the plugin architecture to work right. In older approaches, I used a hybrid of OpenCL and generated kernel arguments + macro helpers to fetch the source terms, and it was a nightmare

In the next article (and into the future[^preon]), we'll be adding even more matter sources as well, so if you're implementing this - now's the time to get this to work correctly. Its far too long to go into here, but check out here (todo: plugin) if you want to see the details of how this works implementation-wise

[^preon]: I might simulate some exotic objects like preon stars eventually, but I'm very likely to come back here with a more modern hydro formalism

## Integration

I use Crank-Nicolson for the hydrodynamics part of this. Backwards-Euler has bad theoretical properties when it comes to fluid dynamics, and it shows - its very dissipative. For people who want to experiment with this, I've included both a relaxation parameter, and a configurable implicitness parameter. The paper that we're looking at weights the integration a little towards the implicit side (and uses a value of $0.6$), but I haven't found this useful

A very interesting and related result I came across when researching this is that you should [never use more than two iterations](https://scispace.com/pdf/stability-of-the-iterated-crank-nicholson-method-in-1jb7vdqz8u.pdf) for Crank-Nicolson. Its not actually strictly true - while higher iteration values don't improve the accuracy, they *do* increase the CFL limit - but the part about the method being unstable for various iteration values is interesting

## Performance

The vast majority of our grid has no fluid in it, so simulating the evolution equations there is completely pointless. Because we're limited solely by memory bandwidth - if we early-out via some condition, we can avoid reading a whole lot of memory. This is great for performance

The correct condition to use is as follows:

```c++
if_e(p_star <= min_p_star, [&]{
    valuef dp_sum = 0;

    for(int i=0; i < 3; i++)
    {
        dp_sum += fabs(diff1(p_star, i, d));
    }

    if_e(dp_sum == 0, [&]{
        //or whatever fields are applicable
        as_ref(Q_out[pos, dim]) = valuef(0);
        return_e();
    });
});
```

This relies on your stencil widths for your derivatives being the same or greater than your maximum stencil width for the hydro implementation

I do this for all kernels, ie $w$, $Q$, and the evolution equations themselves. This results in the entire hydrodynamics formalism becoming very cheap to simulate, as 95% of our grid is empty and can be early-outed with effectively a single memory read + corresponding writes. There's still a reasonable amount of overhead in the BSSN kernel itself however, as we still must read the hydro quantities

Overall, the performance of this method has a roughly ~20% overhead compared to a vacuum simulation - roughly 80ms/tick, from 67ms/tick for an equivalent vacuum simulation. The hydrodynamic equations *themselves* take only a few ms out of an ~80ms/tick runtime, so its largely just extra memory read overhead
