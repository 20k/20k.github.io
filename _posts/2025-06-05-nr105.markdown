---
layout: post
title:  "Numerical Relativity 105: Smashing neutron stars together like its 2002"
date:   2026-02-02 12:33:23 +0000
categories: C++
published: false
---

Hi! Its finally time to do something truly spectacular, and smash some neutron stars together. We'll be discussing how relativistic hydrodynamics works, how it compares to regular hydrodynamics, and some of the various approaches present in the literature

If you're here simply for the montage of black holes eating neutron stars: good news, there's a compilation at the end of this article

But first up: Some background

# What is hydrodynamics?

If you're like me, at some point you might not even really have known why hydrodynamics is a separate area of inquiry to just solving PDEs in general. Or, you might just think its an umbrella term for people who apply the same techniques we've been using already, but simply to fluids

This is incorrect. A fair chunk of this article is going to be explaining what hydrodynamics is, why we need to use different solving methods, and how that fits into general relativity. A lot of programmers' experience of fluid dynamics is the incompressible Navier-Stokes equations, so you might be wondering how similar that it is to what we're trying to do today (disclaimer: not very)

So today's article is going to contain a fair bit of information about regular hydrodynamics

There are three major classes of hydro formalisms

Todo: Massively simplify this

## Lagrangian

In the lagrangian approach, we track a number of particles around a grid. This is common in techniques like smooth particle hydrodynamics. In essence, you can construct a pseudo fluid at each point by interpolating particle properties, and then moving your particles along. We won't be going near this today, but it *is* used occasionally for GR

Lagrangian formalisms don't need grid cells, as their primary unit of information is the particle

Todo: Pictures

## Semi-Lagrangian

If your understanding of hydro is the programmers' understanding, the common style of solving Navier-Stokes is known as a Semi-Lagrangian scheme. In this approach, we have a series of grid cells representing our fluid. At each point, you look up the current cell's velocity, and trace backwards in time to find out where it could have originated from, and look up fluid quantities there

Because we're tracing backwards on our grid as if we're a particle, this is vaguely a halfway house between the Lagrangian approach, and the Eularian approach, which we're about to get to

Todo: Pictures

## Eularian

In this approach, we discretise the same as the Semi-Lagrangian approach, with our fluid properties in grid cells. However, we update our fluid quantities purely *locally*. To find our cell's update, its a function of the velocity around the cell, which we estimate via the derivatives

The Eularian approach is what we'll be doing today. It matches well to General Relativity - as it does not involve any kind of non-local (or a-causal) estimates, through a curved spacetime - except as introduced via discretisation

We'll get to the differences between hydro, and simple PDE solving, after we introduce the relativistic portions of this article. There are a bunch of other techniques as well like lattice Boltzmann if you're interested, this is just the major schemes

Todo: Pictures

# Relativistic Eularian Hydrodynamics

We're going to be looking at two papers today, primarily the latter:

[Fully general relativistic simulation of coalescing binary neutron stars: Preparatory tests](https://arxiv.org/pdf/gr-qc/9908027)

[Hydrodynamic Simulations in 3+1 General Relativity](https://arxiv.org/pdf/gr-qc/0209102)

Note that there was a significant shift in approach from the first paper, to the second, and we'll be using the second's notation and equations

In this approach, we have the following variables for our fluid dynamics:

|Notation | What does it represent |
|-|-|
|$\rho_*$| Rest mass |
|$e_*$| Energy |
|$\tilde{S}_k$ | Momentum (ish) |

This is what we'll be evolving directly. I've translated the paper's old-style conformal factor $\phi$, into our newer conformal factor $W$. A table of conversions is provided at the end of this article

We have the following definitions:

|Variable |Definition | Notes |
|-|-|-|
|$\rho_*$ | $\rho_0 \alpha u^0 W^{-3} $ | |
|$e_*$ | $(\rho_0 \epsilon)^\frac{1}{\Gamma} \alpha u^0 W^{-3}$ | Unclear how a numerical equation of state would work, or if a varying $\Gamma$ is valid |
|$\tilde{S}_k$ | $\rho_* h u_k$ | |
| $h$ | $1 + \epsilon + \frac{P}{\rho_0}$ | $1 + \Gamma \epsilon$ with the perfect fluid equation of state, $P = (\Gamma - 1) \rho_0 \epsilon$ |
|$w$ | $\rho_* \alpha u^0$ | Must be calculated via an iterative procedure |
|$v^i$ | $\frac{u^i}{u^0}$ | Represents a coordinate velocity |

The notation in this article is harmonised with the previous one. $\rho_0$ is the rest-mass density, $\epsilon$ is the specific energy density, $u^0$ is the lorentz factor, and $\alpha$ is the lapse. I also won't be fighting with the paper, and we'll be using a perfect fluid equation of state - because its unclear how a numerical one would work here

## Initialising our variables

At the end of the previous article, we ended up with our fluid quantities: $\rho_0$, $\epsilon$, $u^i$, and $u^0$

There are two pitfall traps here:

1. The initial procedure we used last time appears to have assumed implicitly that $\alpha = 1$, and $\beta^i = 0$ - so use these when initialising regardless of what you actually pick for them
2. $u_i = \beta^i u^0 + \gamma_{ik} u^k$. If you want to prove this, calculate $u_i = g_{i\nu} u^\nu$. There's maths in the appendix

We can now carry on immediately from our last article, which follows on as such:

```c++
valuef pressure = mu_to_P(mu);
valuef p0 = pressure_to_p0(pressure);

valuef epsilon = (mu / p0) - 1;

//with raised index
v3f ui = Si / ((mu + pressure) * u0);

valuef gA = 1;
v3f gB = {0,0,0};

valuef p_star = p0 * gA * u0 * pow(cW, -3);
valuef e_star = pow(p0 * epsilon, (1/Gamma)) * gA * u0 * pow(cW, -3);

v3f u_i;

for(int i=0; i < 3; i++)
{
    valuef sum = 0;

    for(int k=0; k < 3; k++)
    {
        sum += Yij[i, k] * ui[k];
    }

    u_i[i] = gB[i] * u0 + sum;
}

valuef h = calculate_h_from_epsilon(epsilon);

v3f Si_lo_cfl = p_star * h * u_i;

as_ref(hydro.p_star[pos, dim]) = p_star;
as_ref(hydro.e_star[pos, dim]) = e_star;
as_ref(hydro.Si[0][pos, dim]) = Si_lo_cfl[0];
as_ref(hydro.Si[1][pos, dim]) = Si_lo_cfl[1];
as_ref(hydro.Si[2][pos, dim]) = Si_lo_cfl[2];
```

Where:

```c++
valuef calculate_h_from_epsilon(valuef epsilon)
{
    return 1 + get_Gamma() * epsilon;
}
```

That's it, no other surprises

## Evolution equations

So far, so good. Lets look into the basic set of evolution equations [(26-28)](https://arxiv.org/pdf/gr-qc/0209102):

$$\begin{align}
\partial_t p_* + \partial_i(p_* v^i) &= 0\\
\partial_t e_* + \partial_i(e_* v^i) &= 0\\
\partial_t \tilde{S}_k + \partial_i(\tilde{S}_k v^i) &=
                       - \alpha \frac{1}{W^3} \partial_k P - w h \partial_k \alpha \\
                       &-\tilde{S}_j \partial_k \beta^j + \frac{\alpha W^2\tilde{S}_i \tilde{S}_j}{2wh} \partial_k \tilde{\gamma}^{ij}\\
                       &+ \frac{\alpha h(w^2 - p_*^2)}{w} \frac{\partial_k W}{W}
\end{align}
$$

### The reason why hydrodynamics is a thing

We'll get around to some implementing soon. But first: lets talk about these equations in a generic form:

$$\begin{align}
\partial_t p_* &+ \nabla  (p_* \textbf{v}) = 0\\
\partial_t e_* &+ \nabla  (e_* \textbf{v}) = 0\\
\partial_t \tilde{S}_k &+ \nabla  (\tilde{S}_k \textbf{v}) = Source\\
\end{align}$$

Or more generally:

$$
\partial_t q + \nabla (q \textbf{v}) = Source
$$

This is the standard representation in hydrodynamics of advection equations, with the right hand side being called a source term (which you shouldn't confuse with an ADM source term). In general, the source terms are split out, and no special treatment is given to their solving, so we're going to now unceremoniously ignore them

In hydrodynamics there are things called *conserved quantities* - like rest mass, energy, and momentum for a fluid dynamics simulation. The idea behind a conserved quantity is that we want it to be conserved (unsurprisingly), ie a good simulation should keep the total rest mass exact

Naively, you might think to discretise $\partial_i(p_* v^i)$ as something like this, like all our other derivatives:

```c++
auto do_p_star = [&](valuef p_star, v3f v, int i) {
    return diff1(p_star * v[i], i, d);
};

valuef sum = 0;

for(int i=0; i < 3; i++) {
    sum += do_p_star(p_star, v, i);
}
```

This kind of discretisation makes no guarantees about conservation. While it will work, in general the hydro people will be very angry at you, and your simulation will be physically very suspect. What's the alternative?

# Hydrodynamics 101: A crash course

This is one of the few times we'll be chatting about something which isn't directly general relativity, which puts this outside my expertise. If you do hydrodynamics and know cool things about fancy high resolution schemes: please get in touch[^anything]

[^anything]: In general, I'll implement anything I can get my hands on which has a complete set of equations for it

Eularian hydrodynamics in general is concerned with solving equations of this form:

$$\partial_t q + \nabla (q \textbf{v}) = Source$$

This is generally broken up into three 1D problems (which are summed):

$$\partial_t q + \partial_x(q v_x) = Source$$

Good techniques for solving this have the following properties:

1. They conserve your quantity $q$
2. They handle 'shocks', ie discontinuities in $q$
3. They don't produce oscillations that build up and cause everything to break

These are expressed as more technical requirements:

| Term | Meaning|
|-|-|
| Finite Volume | A specific technique for guaranteeing conservation |
| Shock capturing | Everything doesn't blow up when there are discontinuities in $q$, like significant pressure changes |
| Total Variation Dimishing (TVD) | The discretisation method doesn't produce increasing oscillations near discontinuities |
| High resolution | Has a higher spatial order of 2+ in smooth parts of the solution. Currently, we're a 4th order NR sim |

In numerical relativity, 'shocks' are partially handled via Kreiss-Oliger dissipation[^ramble] - but the equations don't tend to produce the kinds of errors you can get with hydrodynamics. Kreiss-Oliger isn't really appropriate to hydrodynamics, as it won't conserve our variables

[^ramble]: Kreiss-Oliger dissipation is only intended to handle problems that build up as a result of finite difference truncation errors. These can cause oscillations. It is however implicitly - perhaps unintentionally - used to smooth the grid in general. Particularly, singularities (being a discontinuity, ie a shock) are smoothed out by Kreiss-Oliger, which damps it. I don't know that this multipurpose function of Kreiss-Oliger is strictly intended, but it appears to be common. Shocks in NR also appear to be uncommon in practice, whereas they are very common in fluid dynamics necessitating different solving techniques

[Appendix A](https://arxiv.org/pdf/gr-qc/0209102) in the paper we're looking at describes a hydro treatment: but as far as I can tell, the description is significantly incomplete. We're going to have to come up with something different, which means: learning

## Conservative discretisation

https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf

The basic form of these discretisations is as follows. First off, we define a *flux* as the following quantity:

$$f_i = v_i q_i$$

$_i$ is a grid cell offset - I'm not going to try and fight hydro notation, its just going to clash terribly with tensor index notation and we'll live with it. The conservative discretisation scheme is then as follows [4.4](https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf):

$$\partial_t q = \frac{1}{\Delta x} (F^n_{i-\frac{1}{2}} - F^n_{i+\frac{1}{2}})$$

where $\Delta x$ is the scale. This is the flux conserving form, and is generic across any hydrodynamics scheme. Solving for the half grid cell flux at the boundary between our grid cells is the joy of hydrodynamics

High resolution schemes often mix and match between different orders in different smoothness areas - having a lower order in less smooth areas. There's some interesting [theoretical reasons](https://en.wikipedia.org/wiki/Godunov%27s_theorem) as to why

I'm not going to attempt to document hydrodynamics in general here, so its time to look at a specific form of solving this equation. It fulfills all the requirements for a 'good' technique, as well as the major requirement which is having a workable set of equations that I can implement[^implement]

[^implement]: Going for a dig through the hydrodynamics literature is surprising. Every field develops its own notation and language, and hydrodynamics appears to have developed its own convention for which steps are omitted when describing a particular scheme. Finding documentation on those omitted steps is surprisingly challenging. That's the core reason why these articles come with a working, testable implementation that you can dig through, and why code often makes much better documentation than papers in my experience

https://www.astro.uzh.ch/~stadel/lib/exe/fetch.php?media=spin:compastro_godunov.pdf todo: contains a note on flux

## A specific scheme: MUSCL

This scheme swaps between second order, and first order, by using a limiter function to swap between the two. As the fluid gradient gets too high, the scheme decays to first order[^notes]. Different limiters have different properties - some introduce lots of diffusion, some accidentally introduce oscillations. The most common, least diffusive limiter, appears to be known as 'superbee', which we'll be using

[^notes]: This is one of the reasons why higher order fluid simulations are less useful than they might appear. High order in smooth areas only is all well and good, but that's also precisely where we need the least resolution

These limited functions then have upwinding applied to them, to result in a stable scheme

There's two different forms of these equations, slope limited, and flux limited. A good explicit reference is [here](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf)

### Slope limited

https://arxiv.org/pdf/1705.10608

[4.33](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf)

$$
F^n_{i - \frac{1}{2}} =
\begin{cases}
\begin{align}
&u_{i - \frac{1}{2}} q_{i - 1} + \frac{1}{2} u_{i - \frac{1}{2}} (\Delta x - u_{i - \frac{1}{2}} \Delta t) \sigma_{i-1}  \;\; &\mathrm{if}\;\; u_{i - \frac{1}{2}} >= 0 \\
&u_{i - \frac{1}{2}} q_{i} - \frac{1}{2} u_{i - \frac{1}{2}} (\Delta x + u_{i - \frac{1}{2}} \Delta t) \sigma_{i} \;\; &\mathrm{if}\;\; u_{i - \frac{1}{2}} <= 0 \\
\end{align}
\end{cases}
$$

$\sigma_i$ is a a slope limiter, see [4.4.2](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf) for examples

### Flux limited

[6.30](https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf) and [4.38](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf) are equivalent:

$$\begin{align}
F^n_{i - 1/2} &= u_{i - 1/2}^- q_i + u_{i - 1/2}^+ q_{i - 1} + \frac{1}{2} \mid u \mid (1 - \mid \frac{u_{i - 1/2} \Delta t}{\Delta x} \mid) \delta_{i - 1/2}\\
\\
\delta_{i-1/2} &= \phi(\theta_{i - 1/2}) (q_i - q_{i - 1})\\
\bar{u}^+_{i-1/2} &= \mathrm{max}(u_{i-1/2}, 0)\\
\bar{u}^-_{i-1/2} &= \mathrm{min}(u_{i-1/2}, 0)\\
\end{align}
$$

Where [(4.37)](https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2012/Chapter_4.pdf):

$$\begin{cases}
\begin{align}
\theta_{i - 1/2} &= \frac{q_{i - 1} - q_{i - 2}}{q_i - q_{i - 1}} \;\; &\mathrm{if} \;\; u_{i - 1/2} >= 0\\
\theta_{i - 1/2} &= \frac{q_{i + 1} - q_i}{q_i - q_{i - 1}} \;\; &\mathrm{if} \;\; u_{i - 1/2} <= 0 \\
\end{align}
\end{cases}
$$

$\phi$ is a *flux* limiter. There's nothing fundamentally that different here to the slope limiting equations - this form seems to be largely to avoid the selection operator that you see in the slope limited version. We'll be using the superbee limiter:

$$\phi(r) = \mathrm{max}(0, \mathrm{min}(1, 2r), \mathrm{min}(2, r))$$

The calculation for $F^n_{i + 1/2} $ is identical, just with $i$ incremented

## The half velocity

There are two ways that I've seen to calculate this half velocity:

1. $v^{n}_{i - 1/2} = \frac{v^{n}_{i} + v^{n}_{i - 1}}{2}$
2. $v^{n}_{i - 1/2} = \frac{p_{*i} v_i + p_{*i-1} v_{i-1}}{p_{*i} + p_{*i-1}}$

$p_*$ is our rest mass. I've also tested a second order interpolation:

$$v^{n}_{i - 1/2} = -0.0625 v^n_{i - 2} + 0.5625 v^n_{i - 1}+ 0.5625 v^n_i - 0.0625 v^n_{i + 1}$$

In general, these options seem to be fairly identical, so you may as well use the first. I've been using the second purely for commonality with the referenced paper

If you're wondering why we don't just reconstruct the flux directly, and limit that without using a half velocity at all: The answer seems to be because of the upwinding scheme. If you try and approach it like this, the reconstructed flux's velocity, and the velocity you use to toggle the upwind direction will differ - which leads to an incorrect solution - I think

More advanced solvers I believe use a Riemann solver instead of upwinding (?), which renders this unnecessary, but requires more information

## Relativistic hydrodynamics

https://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2009/Chapter_6.pdf

In theory, the hydrodynamics is now done

Here's where there's a small problem: Despite our equations looking like a conservative hydrodynamics equation, they actually are not. While I believe that $p_*$ *is* in conservative form, $e_*$ is not and is not a conserved quantity across shocks - so we'll have to artificially dissipate them despite using a shock capturing formalism. I have absolutely no idea about $\tilde{S}_k$

In general, this is one of the reasons why this formalism was abandoned fairly quickly - more modern formalisms are expressed purely in terms of conserved quantities, which makes their hydro treatment more theoretically rigorous with only some minor performance downsides. I'll get more to this point in the discussion

# Evolution Equations

With that, we can implement the above scheme for all the $\partial_i(q v^i)$ terms, which works great. You can just add the source terms on afterwards, and sum each different direction for the hydro scheme (this is technically an 'unsplit' method)

There's two other nontrivial terms to talk about now: $v^i$ and $w$

## $v^i$

The quantity $v^i$ is as follows:

$$v^i = -\beta^i + \frac{W^2 \alpha \tilde{\gamma}^{ij} \tilde{S}_j}{w h}$$

This can either be worked out from [2.12](https://arxiv.org/pdf/gr-qc/9908027) and converting their variables, or by calculating:

$$
\begin{align}
u_k &= \frac{\tilde{S}_k}{p_* h}\\
u^i &= g^{i\nu} u_{\nu}\\
v^i &= \frac{u^i}{u^0}
\end{align}
$$

You'll also have to work out the quantity $u_0$ if you're deriving this by hand. Todo: Do this at the end of the article

## $w$

This quantity is much less fun. It has the following form (29):

$$w^2 = p_*^2+ W^2 \tilde{\gamma}^{ij}\tilde{S}_i \tilde{S}_j \left[1 + \frac{\Gamma e_*^{\Gamma}}{p_*(w \frac{e^{6\phi}}{p_*})^{\Gamma-1}} \right]^{-2}$$

There are two problems:

1. There is no analytic solution
2. It divides by zero a fair bit

We can solve #1 by using fixed point iteration with the initial guess $w=\rho_*$ as this is a lorentz factor multiplied by density terms. Simply plug in your guess into the right hand side, calculate the new value of $w$, and rinse and repeat. #2 is more of a pain

The way this equation is structured out of the box is slightly cursed. Lets rearrange it a bit:

$$\begin{align}
A &= (W^3)^{\Gamma-1}\\
D &= \frac{w^{\Gamma-1}}{w^{\Gamma-1} + A \Gamma e_*^{\Gamma} p_*^{\Gamma-2}}\\
w^2 &= p_*^2 + W^2 \tilde{\gamma}^{ij} \tilde{S}_i \tilde{S}_j D^2\\
\end{align}
$$

The singular part is the divisor of $D$, and to fix it you can simply clamp the bottom to a small constant. We'll be getting back to the singular division issue later, as we'll be handling it systematically

Its worth noting here that when $\Gamma = 2$, the factor of $p_*$ drops out in $D$

## Recovering the primitive variables

$\rho_0$ and $\epsilon$ are called the primitive hydrodynamic variables, and recovering them requires $w$. Once you have that, you can calculate:

$$\begin{align}
\rho_0 &= \frac{W^3 p_*^2}{w}\\
\epsilon &= e_*^\Gamma p_*^{\Gamma - 2} (\frac{W^3}{w})^{\Gamma - 1}
\end{align}
$$

In general, its a good idea to avoid calculating $\rho_0$ if possible, as calculating $p_*^2$ is numerically suspect with small quantities. Some usefully optimised quantities are:

$$\begin{align}
\rho_0 \epsilon &= \left (e_* W^3 \frac{p_*}{w} \right)^\Gamma\\
h &= 1 + \Gamma \epsilon
\end{align}
$$

## ADM Source terms

The way matter integrates into the BSSN equations is via something known as source terms. These make up the components of the stress energy tensor (which up until now, has been 0), which are fed into our BSSN/ADM equations to make matter work

There are four standard ADM source terms:

$$\begin{align}
\rho_H &= h w W^3 - P\\
S_i &= W^3\tilde{S}_i\\
S_{ij} &= \frac{W^3}{wh}\tilde{S}_i \tilde{S}_j + P \gamma_{ij}\\
S &= \gamma^{ij} S_{ij} = W^2 \tilde{\gamma}^{ij} S_{ij} \\
\end{align}$$

There's a minor problem: $S_{ij}$ is singular at the singularity. The issue is that $\gamma_{ij}$ is undefined

Luckily, we can skip to the future, and discover that the form of our $S_{ij}$ source term is actually: $-W^2 8 \pi \alpha S_{ij}$[^alttechnique]. Given that $$W^2 \gamma_{ij} = \tilde{\gamma}_{ij}$$, we can instead re-format our equations like this:

[^alttechnique]: Calculating the pressure involves calculating the quantity $\rho_0 \epsilon$: we could scavenge one of the $W^2$ terms from that calculation to instead remove the $\gamma_{ij}$ term. However, the construction presented is a slightly more general approach that we can use in other methods, rather than relying on the *specific* form of the source terms, so we'll stick with it

$$
\begin{align}
\tilde{S}_{ij} &= \frac{W^5}{wh} \tilde{S}_i \tilde{S}_j + P \tilde{\gamma}_{ij}\\
S &=\tilde{\gamma}^{ij} \tilde{S}_{ij} \\
\end{align}
$$

We'll have to modify our BSSN source term to match the absorbed $W^2$ term (ie $-8 \pi \alpha S_{ij}$), but now our source terms become regular at the metric tensor. This is a minor improvement over the standard arrangement

## The BSSN equations

The additions are straightforward:

$$\begin{align}
\partial_t K &\mathrel{+}= 4 \pi \alpha (S + \rho_H)\\
\partial_t \tilde{A}_{ij} &\mathrel{+}= -8 \pi \alpha \tilde{S}_{ij}^{TF}\\
\partial_t \tilde{\Gamma}^i &\mathrel{+}= -16 \pi \alpha \tilde{\gamma}^{ij} S_j\\
\mathcal{H} &\mathrel{+}= -16 \pi \rho_H\\
\mathcal{M}_i &\mathrel{+}= -8 \pi S_i\\
\end{align}$$

The source terms conspire very conveniently to avoid having to calculate infinite quantities at the singularity which is great. The only infinities we have to worry about are in the actual hydrodynamic evolution equations themselves

# Artificial Viscosity

One of the big problems with our equations is that they actually aren't conservative: one key thing is that $e^*$ isn't actually conserved in the presence of shocks. To combat this, this scheme introduces a small amount of artificial viscosity to dissipate shocks away

A lot of papers here are quite vague as to how exactly to modify the viscosity. A complete description of this scheme requires us to go all the way back to [1984](https://adsabs.harvard.edu/full/1984ApJS...55..211H), where the extra viscous pressure is called $Q$. This is used in two places:

1. It is added to the pressure on the right hand side of $\partial_t \tilde{S}_k$, ie $\partial_k (P + Q)$
2. We have a new rhs for $e^*$, which we'll get into shortly

There are two complementary ways to calculate this additional pressure term $Q$

1. Quadratic viscosity
2. Linear viscosity

You can sum these

## Quadratic Viscosity

$$\begin{align}
Q_{Qvis} =
\begin{cases}
C_{Qvis}A(\delta v)^2\;\;&\mathrm{for} \;\delta v < 0\\
0 \; &\mathrm{otherwise}
\end{cases}
\end{align}$$

Where:

$$\begin{align}
A &= e_*^\Gamma (W^3)^{\Gamma-1} \frac{p_*^{\Gamma-1}}{w^{\Gamma-1}}\\
\delta v &= 2 \partial_k v^k \Delta h
\end{align}$$

And $$\Delta h$$ is the scale. $C_{Qvis}$ is a damping constant, which I set to $0.1$, and this paper recommends the range $[0.1, 1]$

Quadratic viscosity is generally left on throughout a simulation, but is disabled near a singularity. In theory, you could probably derive the strength of the quadratic viscosity from a hydrodynamic smoothness estimate to remove dissipation in unsmooth parts of the solution, but I have no information on if that's worthwhile

## Linear viscosity

$$\begin{align}
Q_{Lvis} =
\begin{cases}
-C_{Lvis}\sqrt{(\Gamma/n) p_* A}\;\;&\mathrm{for} \;\delta v < 0\\
0 \; &\mathrm{otherwise}
\end{cases}
\end{align}$$

$C_{Lvis}$ is a damping constant in the range $[0, 1]$. In my case, I set this damping constant as follows:

$$C_{Lvis} = e^{-\frac{t^2}{2 T^2}}$$

$T$ is a constant that represents a damping timescale for the linear viscosity, as it is generally only useful in the early parts of the simulation to iron out the star's oscillations. Leaving it on too long will result in a loss of velocity, and $T=200$ seems to work well

I don't have a clue what $n$ is and have never been able to find a single shred of discussion on what it represents, so I set it to $1$

Without linear viscosity:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/2oUI7VQ8aN0?si=nyjyIqzv1RC0tcEC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

With linear viscosity:

\<iframe width="560" height="315" src="https://www.youtube.com/embed/YS4AoDqNOe4?si=4NY-GpvEqy2VY9zh" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Viscosity $e_*$

When using viscosity, you have to modify the evolution equation of $e_*$. The term to add is:

$$\partial_t e_* += -(\rho_0 \epsilon)^{(-1 + \frac{1}{\Gamma})} \;\; \frac{Q}{\Gamma} \; \partial_k (w W^{-3} v^k p_*^{-1})$$

## Viscosity conclusion

In general, linear viscosity is good for large scale damping and significantly improves the simulations stability. Our initial conditions are quite approximate and the stars relax into their final form, so damping this initial relaxation improves the simulation a lot, and produces stable non oscillating neutron stars. Quadratic viscosity is less applicable, as shocks aren't common in these simulations and so it has minimal effect - I also have a feeling that the much higher resolution, and somewhat more modern hydro approach significantly helps here

The viscosity scheme documented in this paper is actually not consistent - its an ad-hoc modification to fix up shocks. There is, in theory, a full hydro formalism which includes a consistent treatment of viscosity which works for ultrarelativistic matter - but unfortunately its behind a paywall Todo, link. Given that nobody really uses this formalism anymore, its likely not worth worry about - and instead simply using a newer formalism

# Implementation Details

There are a variety of implementation details that tend not to be discussed, that I will now dig into

## Divisions by zero

As you may have noticed, our equations involve quite a bit of dividing by zero. In general, there are many instances of divisions by $w$, or $W$, which we'll have to deal with

In general, this is pretty straightforward. For division by $W$, I clamp $W$ to $0.1$. This might seem quite large, but in general we don't really care about the hydrodynamics near the singularity of a black hole, and its more important for the equations to remain regular

For divisions by equations involving $\rho_*$ or $w$, I use a division tolerance of $1e-7$, of the following form:

```c++
template<typename T>
auto safe_divide(const auto& top, const T& bottom, float tol = 1e-7f)
{
    valuef bsign = ternary(bottom >= 0, valuef(1.f), valuef(-1.f));

    return ternary(fabs(bottom) <= tol, top / (bsign * tol), top / bottom);
}
```

## Non atmospheric hydrodynamics

One of the key aspects of this paper is the non-atmospheric aspect of it. The idea here is that when $\rho_* < \rho_{min}$, you flush all your evolution variables to $0$ for a true vacuum. This leaves a few questions about exactly how and when to flush your evolution variables to zero

We're using a pretty different integration scheme (backwards Euler + Crank-Nicolson) compared to the paper. To take a pure backwards Euler scheme as an example, you may be tempted to flush variables to zero at the end of a backwards Euler substep - this is actually the wrong choice. Consider that the next backwards Euler iteration is calculated as:

$$next = base + f(in)$$

If our cell value is just below $\rho_{min}$, and our neighbours are above, in the next iteration there'll be effectively a hole in the simulation grid which fluid will rush into. Because $base$ is nonzero, this means that we'll end up with too much fluid in our current cell. This can cause an oscillatory behaviour which doesn't converge very well

Instead, I copy the current cell value over if $\rho_* < \rho_{min}$, and only perform a flush after the whole step is resolved

Because the amount of matter flushed to vaccum is proportional to the grid surface area of the star, there is a small loss of mass as the simulation progresses. This is unfortunate

## Operator Splitting

Our equations are of the form:

$$\partial_t X + \partial_i (X v^i) = \mathrm{source}$$

Operator splitting means that you update all the advection terms first, and then evaluate all source terms post advection - which smells a bit like a backwards Euler step

I did some fairly extensive testing of various operator splitting methods vs treating these as regular evolution equations for this article, and was not able to find any stability difference at all. Operator splitting requires a few extra buffers for storage of intermediate variables, so in this case it was strictly worse. It may be because we're using an implicit scheme with much higher resolution

## Black Hole Collapse

Matter within a black hole in the set of equations I'm presenting here is only moderately badly behaved at the singularity, which is frankly incredible. You do need to do two things to make this work well:

1. Disable all viscosity in the vicinity of an event horizon
2. Dissipate all the matter fields to zero when within an event horizon

In general, the lapse $\alpha$ is a good surrogate variable for being near an event horizon. I use a conservative $0.45$ for disabling viscosity, and $0.15$ for dissipating matter fields. The latter constraint imposes a minimum simulation resolution to successfully simulate a black hole collapse, as the simulation will eventually fail if matter is not damped within an event horizon

## Boundaries

The Sommerfeld boundary conditions I find tend to be a bit unstable with matter. Simply damping the fields away to zero as they approach the boundary works very well. This means you can turn the usual radiative boundary condition off

## Kreiss-Oliger

Kreiss-Oliger is not applied to any fields as it would upset the conservation. The hydro scheme being TVD means that it is unnecessary. If you do not use a TVD hydro scheme, you'll want to switch Kreiss-Oliger on, with the obvious ramifications of non conservation of your quantities

## $e_*$ blows up

One documented consequence of the atmosphere-free formulation is that a thin (resolution dependent) shell of material drifts away from the star, and remains suspended around it. This thin shell in theory can end up superheating, causing unfun code times

This paper fixes it by clamping $$e_* = min(e_*, 10 \rho_*)$$. I do this when $\rho_* < 10\rho_{min}$

I haven't found this modification to be at all important in practice, so its disabled by default

## $v^i$'s vacuum boundary is inconsistent

This paper says that when the atmosphere is classed as a vacuum, $v^i = 0$. This is a *very* strange limit: we can see that our equation for $v^i$:

$$v^i = -\beta^i + \frac{W^2 \alpha \tilde{\gamma}^{ij} \tilde{S}_j}{w h}$$

probably tends to $-\beta^i$ when $p^* = 0$, not $0$. I've included this as a configurable tweak (todo) in the code, and it does affect inspiral significantly

Interestingly, the paper we're looking at uses a rotating coordinate frame, which is essentially a velocity applied to the gauge conditions initially (ie $\beta^i$). This possible limit error in combination with the rotating coordinate frame (which results in a strongly non zero $\beta^i$), could lead to a significant discontinuity in the velocity at the edge of the star. This may be the root cause behind this paper's thin shell of material drifting away from the surface, as a significant derivative in the velocity will be generated at the boundary which may fling material away

## Hamiltonian constraint damping

Todo: Chop out at least a paragraph

There are two new major features that I implemented since we last simulated black holes together:

1. Hamiltonian constraint damping
2. No constraint damping near the boundary

Both of these are quite important to reducing simulation errors. I use the following modification to $\partial_t W$:

$$\partial_t W \; \mathrel{+}= \; C \; \Delta t \;\alpha W \mathcal{H}$$

$C$ is a damping strength, set to $0.15$. It is $0$ when the distance to the simulation's boundary is $<10$ in grid cells

The prefix term of $C \Delta t$ is derived from [this](https://arxiv.org/pdf/2404.01137) paper, note that we're using $\mathcal{H}_-$ in that paper's notation

The factor of $- W$ (that simplifies to $W$) comes from transforming this modification from the $\phi$ conformal factor, to our $W$ conformal factor

The near-boundary modification has the effect of significantly reducing boundary constraint contamination of the simulation, compare below: todo

## Source terms

Todo: This is too long

Actually generating the stress energy tensor with its 10 components is a mistake - its much better to directly express the source terms from the underlying formalism, as it saves a huge amount of memory bandwidth. I rarely go into application-level architectural details because it normally isn't relevant, but this is the major exception

Implementing this correctly is extremely difficult to do in a standard programming language in a high performance way, because the BSSN equation implementation itself needs generic, direct access to whatever buffers can derive our source terms (including $w$)

Runtime branching is horrendously expensive here - as in the non hydro case we'll end up with a lot of extra instructions being generated which are unused. The limited instruction cache space is a strong performance bottleneck, as well as VGPR usage (which we push right up against) - and conditional memory accesses are always bad

This issue is actually the major reason which motivated the development of the generated language I use in these articles - as it allows you to generate different kernels depending on what features are enabled, while composing together all the individual sources via a plugin architecture. If you want good performance, I would highly recommend something similar - and a lot of development of this toolkit since the last article has been around getting the plugin architecture to work right. In older approaches, I used a hybrid of OpenCL and generated kernel arguments + macro helpers to fetch the source terms, and it was a nightmare

In the next article (and into the future[^preon]), we'll be adding even more matter sources as well, so if you're implementing this - now's the time to get this to work correctly. Its far too long to go into here, but check out here (todo: plugin) if you want to see the details of how this works implementation-wise

[^preon]: I might simulate some exotic objects like preon stars eventually, but I'm very likely to come back here with a more modern hydro formalism

## Integration

I use Crank-Nicolson for the hydrodynamics part of this. Backwards-Euler has bad theoretical properties when it comes to fluid dynamics, and it shows - its very dissipative. For people who want to experiment with this, I've included both a relaxation parameter, and a configurable implicitness parameter. The paper that we're looking at weights the integration a little towards the implicit side (and uses a value of $0.6$), but I haven't found this useful

A very interesting and related result I came across when researching this is that you should [never use more than two iterations](https://scispace.com/pdf/stability-of-the-iterated-crank-nicholson-method-in-1jb7vdqz8u.pdf) for Crank-Nicolson. Its not actually strictly true - while higher iteration values don't improve the accuracy, they *do* increase the CFL limit - but the part about the method being unstable for various iteration values is interesting

## Performance

The vast majority of our grid has no fluid in it, so simulating the evolution equations there is completely pointless. Because we're limited solely by memory bandwidth - if we early-out via some condition, we can avoid reading a whole lot of memory. This is great for performance

The correct condition to use is as follows:

```c++
if_e(p_star <= min_p_star, [&]{
    valuef dp_sum = 0;

    for(int i=0; i < 3; i++)
    {
        dp_sum += fabs(diff1(p_star, i, d));
    }

    if_e(dp_sum == 0, [&]{
        //or whatever fields are applicable
        as_ref(Q_out[pos, dim]) = valuef(0);
        return_e();
    });
});
```

This relies on your stencil widths for your derivatives being the same or greater than your maximum stencil width for the hydro implementation

I do this for all kernels, ie $w$, $Q$, and the evolution equations themselves. This results in the entire hydrodynamics formalism becoming virtually free to simulate, as 95% of our grid is empty and can be early-outed with effectively a single memory read + corresponding writes

Overall, the performance of this method has a roughly 0% overhead compared to a vacuum simulation. This is because GPU compilers have a long standing personal vendetta against me, and the BSSN evolution equations themselves run *slightly* faster when hydro is turned on for no discernable reason. The hydrodynamic equations take only a few ms out of an ~80ms/tick runtime, so its pretty fantastic overall

In the past, I used a much more complex system to track active fluid around the grid, but this is strictly better by every metric

# Hydro Discussion

Before we get to the results, and overall discussion, its worth talking about this hydro formalism a bit more critically. Digging into a past project again equipped with much more knowledge and a critical eye was absolutely fascinating, and I learnt a lot about hydrodynamics along the way

The formalism I'm talking about today was relatively quickly abandoned in favour of a different approach, which I'll very likely get around to implementing in the near future. All the actual hard parts are done, so plugging in a new formalism is relatively straightforward

As far as I can tell, there's the following issues with this approach:

1. The non atmospheric approach isn't super good in general. Material gets deleted, resulting in mass loss
2. When $\rho_*$ is of the same order of magnitude as $\rho_{min}$, you have to be extremely careful with floating point accuracy. There's a significant amount of error due to precision issues, and some quantities are very poorly behaved
3. The non conservative nature of the equations means that conventional hydrodynamic solutions only have limited applicability
4. The mass-shell-drift problem, although I think that may be a problem with the specific implementation
5. Significant ambiguities exist with how to implement the equations numerically
6. The viscosity treatment is ad-hoc
7. Its unclear how to use a numerical equation of state here

This - in theory - would all be solved by a newer formalism. This formalism isn't 'bad' - and it certainly works. It makes an extremely interesting test-case on modern hardware compared to what they could get away with in 2002

Another thing to add is: We're using an implicit scheme for both the BSSN equations, and the hydrodynamic equations. As mentioned before, simulating the hydrodynamic equations has virtually no performance overhead at all - which means that we should be able to get away with a *much* more expensive formalism for all of the hydrodynamics in this article. Some kind of super duper high resolution predictor-corrector scheme would likely work extremely well, which I'll do as soon as I can find one

# Testing

Do: Spin test

# Its hard to see the spinning

Advecting arbitrary scalar fields

# Merger

# Appendix

$F^n$ is actually an integral in time, ie its meant to be the total movement of material though the cell boundary between steps: $n$ and $n+1$:

$$F^n_{i - 1/2} = \frac{1}{\Delta t} \int^{t_{n+1}}_{t_n} f(q(x_{i-1/2}, t)) dt $$

This equation may be falling out of a specific approximation - I'll hold my hands up here and say I'm not incredibly sure

https://www.tevza.org/home/course/modelling-II_2016/books/Leveque%20-%20Finite%20Volume%20Methods%20for%20Hyperbolic%20Equations.pdf 4.5

## Conformal decomposition

The conformal decomposition is defined as follows: $$\tilde{\gamma}_{ij} = W^2 \gamma_{ij} = e^{-4\phi} \gamma_{ij}$$

|Ours|Theirs|
|-|-|
|$W$|$e^{-2\phi}$|
|$W^2$|$e^{-4\phi}$|
|$W^3$|$e^{-6\phi}$|
|$\frac{1}{W}$|$e^{2\phi}$|
|$\frac{1}{W^2}$|$e^{4\phi}$|
|$\frac{1}{W^3}$|$e^{6\phi}$|
|$-\frac{\partial_i W}{2W}$|$\partial_i \phi$|

This is basic, but it saves a lot of time looking things up when you check the reference paper

## BSSN Equations with source terms