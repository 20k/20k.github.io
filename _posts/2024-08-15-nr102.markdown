---
layout: post
title:  "Numerical Relativity 102: Simulating binary black hole collisions, quickly"
date:   2024-08-15 12:33:23 +0000
categories: C++
---

Hello! Today we're going to do one of the coolest things in all of physics in my opinion, which is simulating the collision of two black holes. Last time round, we implemented most of what we'll need to implement this, so today's job is to capitalise on that and finally smash some black holes together

The complicated part of this article is going to be the initial conditions, which means that most of this article is actually going to be how to solve Laplacians quickly on a GPU

# Astrophysics Context

Its worth understanding for this article what we're actually trying to simulate. A black hole is an object that is so dense that light can't escape - once this happens, nothing that prevent all the matter that made up the precursor object from reaching the singularity

Eg, consider a star collapsing into a black hole. All the matter essentially shrinks to a point (or, in the case of a spinning black hole: a ring) past the event horizon, until it reaches a singularity. In pure general relativity, this singularity is inevitable, and all the black holes we're dealing with today will always contain a singularity. Its also true that the singularity is - mathematically - very poorly behaved and by definition causes all the maths to explode. This makes simulating it a bit tricky. There are two approaches to handling this

## Excision

A black holes interior, and exterior are causally disconnected. This means that the interior of a black hole has no effect on the wider universe, and as such - you don't actually need to simulate it. This is the excision technique for handling a black hole's interior, and involves specifying a boundary condition somewhere inside the event horizon

This also directly leads to one of my favourite papers, the turducken, where you stuff the interior with meaningless junk

## Moving punctures

This is the technique we'll actually be using, and involves a bit of trickery. In the ADM formalism, the gauge conditions define the coordinate system of what you're working with. So the trick is to make sure that the coordinates never actually meet the singularity, and its treated as a puncture/hole in your simulation grid. This puncture is able to move around with the correct gauge conditions, and so we have a singularity that is never actually quite reprsented

In practice, its a lot trickier than this, and I personally have some skepticism that that's actually what's happening. I'm going to keep the crackpot conspiracy theories to the end of this article

## Circular Orbits

The conventional wisdom is that black holes merge after a long inspiralling process, where the nature of gravitational wave emissions slowly circularises the orbits. This means that binary black hole orbits should be nearly perfectly circular by the time the black hole's merge

Unfortunately, this turned out not to be the case, and it appears that there is a significant amount of eccentricity (non circularity) when black holes merge. This really complicates the amount of simulating you have to do

## Unequal mass binaries

With the assumption of circular orbits, equal mass/spin binaries, and the black hole spin being aligned with the plane of the orbit, you can use octant symmetry - ie your simulation is fully symmetric and can be chopped into 8 chunks, with only one of the chunks actually being simulated

Personally I'm interested in a very general simulator which can handle anything, so we're going to avoid this octant symmetry reduction - but given its prevalence in the literature, its worth mentioning here

## Gravitational waves

The primary purpose of a black hole merger simulator is to find out what the gravitational waves look like, because LIGO (a big gravitational wave detector) can detect certain mass ranges of mergers. We're not going to be pulling out gravitational waves today, but it does mean we need to be careful to be as physical as possible

To perform this matching, as far as I know there's no better way than simply bruteforcing the entire parameter space. For a pair of black holes, you have the following parameters:

todo: no

M1: The mass of the first black hole
M2: The mass of the second black hole
S1: The spin direction - a 3-vector - of the first black hole, normalised
S2: The spin direction of the second black hole
X1: The spin constant of the first black hole
X2: The spin constant of the second black hole
e: The orbital eccentricity

This is a lot of parameters to bruteforce, and why non circular orbits are such a gigantic pain, because it adds a whole extra dimension to bruteforce

Traditional simulations in this area can take weeks to months, which you'll be glad to know is not going to be the case for us

# What's the plan?

We need a few things to get this to work

1. A new set of initial conditions
2. New boundary conditions
3. Some modifications to the evolution equations

Of all of these, the initial conditions are by far the most complicated part, so lets get to it

# Initial conditions

I'm going to present you with the easiest set of initial conditions to implement, and we're going to really dig into it. Some discussion about alternatives and further context is given at the end of this article

The paper we're going to implement today is called [A simple construction of initial data for multiple black holes](https://arxiv.org/pdf/gr-qc/9703066). This represents an extremely traditional and widespread way to construct black hole initial conditions - its also a very good paper that you should read. There are a few things that we need to learn right off the bat

1. This doesn't actually make black holes, it makes objects that collapse into black holes. They have no event horizon, or apparent horizon
2. There is no way of a-priori specifying the mass of a black hole
3. There is a maximum value of spin that can be expressed with this technique

Lets get into it

## Implementing

To take a step back, we're trying to solve initial conditions for the following ADM variables:

$$\gamma_{ij}\\
K_{ij}\\
\alpha\\
\beta^i
$$

This technique solves for $\gamma_{ij}$ and $K_{ij}$, and leaves us to guess $\alpha$ and $\beta^i$. It falls under the class of initial conditions known as 'conformally flat'. This means it decomposes the metric tensor into a flat conformal metric (an identity matrix), and a conformal factor $\psi$. It also decomposes the extrinsic curvature $K^{ph}_{ij}$ ('physical', this is our $K_{ij}$) into a trace $K=0$, and a trace free part which this paper calls $K_{ij}$ (and other papers often call $$\bar{A}_{ij}$$). The notation for numerical relativity has changed a lot over the years

The basic idea here is that with the conformally flat + trace free constraint, the momentum constraint becomes linear, allowing you to calculate the extrinsic curvature as a sum of each individual black hole's curvature, to calculate the final (conformal) curvature. The shape of the conformal factor is a *guess*, which is then corrected to be physical via a hopefully small correction, by solving the laplacian (9) + (10)

## Details

This method has the following parameters:

$m_i$ bare mass parameter of each black hole
$P_i$ the momentum vector of each black hole
$S_i$ the spin (angular momentum) of each black hole
$x_i$ the position of a black hole

Note that bare mass is not the same thing as mass (here: ADM mass), it only correlates to it. A black hole's spin contributes to its mass as well. On top of this, in the general case, the mass of a black hole in a binary pair is of questionable physicalness: see the end of this article for more details

I'm going to be using the notation $\bar{A}^{ij}$ to mean what this paper calls $K^{ij}$, because its simply too confusing otherwise. I'm also going to be using $\bar{\gamma}_{ij}$ to mean the conformally flat metric instead of $g_{ab}$, for the same reason

## Conformal extrinsic curvature

This is straightforward. For every black hole in our spacetime, we calculate the quantity (5), and then sum all of them. After accumulating all of these, I store $\bar{A}^{ab} \bar{A}_{ab}$ as a scalar

For a single black hole, we have this:

$$
\begin{align}
\bar{A}^{ij} &= \frac{3}{2r^2}(P^a n^b + P^b n^a - (\bar{\gamma}^{ab} - n^a n^b) P^c n_c) \\
&+ \frac{3}{r^3}(\epsilon^{acd} S_c n_d n^b + \epsilon^{bcd} S_c n_d n^a)
\end{align}
$$

Where $\epsilon$ is the levi civita tensor. Note that the levi civita symbol, and levi civita tensor have the same notation in the literature and are frequently freely mixed, so its not especially clear what's going on. TODO: I NEED TO CHECK THIS

$r$ is the distance in world coordinates (ie not grid coordinates) of the coordinate from the black hole in question. There's a clear problem when $r = 0$, and the solution is to either position your black holes so this is impossible, or clamp to a small value

$n$ is a normal vector, which is calculated as follows: $n^i = x^i/r$, and points away from the black hole in question

If you have no plans to ever work in non cartesian coordinate systems (which we don't), the metric tensor is the identity matrix

Next up: We need the conformal factor $\psi$, which involves calculating the correction $u$

## Conformal Factor

alt https://arxiv.org/pdf/1606.04881

The conformal factor $\psi$ here is listed as:

$$\psi = \frac{1}{\alpha} + u$$

Where $u > 1$, and $\alpha$ is:

$$\frac{1}{\alpha} = \sum^N_{i=1} \frac{m_i}{2 |\overrightarrow{r} - \overrightarrow{x}_{(i)}|}$$

Note that $r$ in the bottom term is a vector representing our current grid cell's world position. This is twice the distance of our coordinate from our $i$'th black hole

We're only going to deviate a little from this definition, and instead calculate the correction as:

$$\psi = \frac{1}{\alpha} + u + 1$$

Where $u > 0$. This is because you have a lot more precision to work with for floating point near zero vs near $1$, so this lets us solve for much smaller corrections without needing to resort to double precision. This means our boundary condition will be slightly different ($u=0$ vs $u=1$)

### Solving laplacians, finding $u$

Equations (9) + (10) are a classic laplacian:

TODO:


And I'm now going to present to you how to solve it. We're extremely lucky in that we're going to be running this on a GPU, so we don't have to do anything too fancy to solve this very quickly

i'm too hungry to write any more sensibly, but tl;dr

write the general form of the equation Du = whatevz
discretise the left hand side to get ye olde stencil
rearrange to get the fixed point iteration
present the basic fixed point iteration solution
introduce red-black
introduce multigrid

## Fin

With the laplacian solved, you calculated $\psi$, and the construct the ADM variables blahblah. From there we have the BSSN variables

The ADM mass can be estimated via blahblah. If you need a specific ADM mass, iterate. Binary search. Spin! Woo!

### Gauge

Innit

# Boundary conditions

Radiative

# Stability modifications

Rawr

# Results

Look! Black holes!


# Black holes do not really have mass

There's an unfortunate truth for black holes, which is that there is no unique definition of the mass of a black hole. Its very easy to work out how much mass there is for something like the earth - because we can calculate how much *matter* is present, but black holes here are a vacuum solution - there's no matter of any description present. This means that we have to work out what the effect on spacetime a black hole has equivalent to a certain amount of mass

There are multiple definitions of mass that we can use:

1. Bare mass, which has no physical meaning. Higher = more mass, but that's about it
2. ADM mass, which is measured at 'infinity', and measures how much energy is present in the spacetime. Only valid in asymptotically flat spacetimes
3. Komar mass - defined in stationary spacetimes
4. Horizon mass, determined by the area of the event horizon[^notruehorizon]
5. Puncture mass, determined by the size of the correction factor $\psi$ at the puncture, which approximates the ADM mass

[^notruehorizon]: If you were thinking this definition seems very straightforward, note that in a technical sense our numerical black holes don't have an event horizon. An event horizon is the 4d surface which light rays cannot escape from, but as our black holes are not eternal (and are formed by the collapse of a precursor object with no horizon), an event horizon is not present in our spacetime. If you trace a ray backwards in time, it will never become trapped in a black hole

    In the literature, a surface which is hoped to be equivalent/similar is used called the 'marginally outer trapped surface' (MOTS), which is defined locally on a specific slice. It is not the same thing as an event horizon, which can only truly be determined by tracing geodesics around in a 4-spacetime. You could also define a point in time to be approximately the 'start' of our black holes after they've formed from the precursor objects, and use that to approximate an enernal black hole (and so define a true event horizon) while tracing geodesics. I'm not aware of anyone doing this though

Black holes are a form of energy stored in spacetime and are a global phenomenon. Two black holes which are nearby each other store a significant amount of energy in the spacetime between them, increasing their mass (essentially further delocalising them). This makes it hard to pin down exactly how much 'mass' an individual black hole has in a binary pair, because they aren't truly separate phenonema. This means that all of these definitions of mass can disagree

Despite this, its very common to use ADM mass via puncture mass, and horizon mass with an approximation to its event horizon[^notruehorizon]. We'll be using the former
