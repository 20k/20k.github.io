---
layout: post
title:  "Implementing General Relativity: What's inside a black hole?"
date:   2025-05-18 00:35:23 +0000
categories: C++
---

Hello! Today we're going to do something really cool: Throw ourselves into a black hole and find out what happens. To do this, we need to upgrade our understanding of initial conditions in general relativity via tetrads, and we're also going to learn what parallel transport is

The scope of this article is as follows:

1. First we examine the role of coordinate systems in general relativity
2. Then we'll upgrade to a black hole metric which lets us cross the event horizon
3. After this, we'll learn how to calculate initial conditions for *any* metric tensor, instead of using pre-baked initial conditions
4. You're going to understand how to take a frame of reference, and 'boost' it to represent a moving observer
5. Then we'll learn how to follow the path that an observer takes as it moves around spacetime - and in our case, into whatever lies inside a black hole
6. After this, we'll upgrade to a much more exciting, spinning black hole
7. There will be at least one cat photo in this article

This will all be on the GPU, so it'll run reasonably fast. We're starting to get into things that people haven't really simulated before, and this is an area where many simulations are incorrect

# Myths

This article will examine several things that people often state are true in general relativity, and we'll reference this list when we're able to disprove each item

1. As you fall into a black hole, the universe turns into a point behind you, and winks out of existence
2. It takes forever to fall into a black hole
3. When you cross the event horizon of a black hole, you see the universe age infinitely

# Coordinate systems

In the first episode on rendering the schwarzschild black hole, I presented you with this:

$$ ds^2 = -d\tau^2 = -(1-\frac{r_s}{r}) dt^2 + (1-\frac{r_s}{r})^{-1} dr^2 + r^2 d\Omega^2 $$

where $d\Omega^2 = d\theta^2 + sin^2(\theta) d\phi^2$

And called it the metric tensor for a schwarzschild black hole. This was a white lie - this is, in the more technical sense, *a* representation of the schwarzschild black hole, in a particular coordinate system known as schwarzschild coordinates. Here's another representation:

$$ ds^2 = -(1-rs/r) dv^2 + 2 dvdr + r^2 d\Omega^2 $$

In eddington-finkelstein coordinates. And another:

$$ ds^2 = -d\tau^2 + rs/r dp^2 + r^2 d\Omega^2 $$

In Lema√Ætre coordinates. Note that the $d\tau$ is not proper time, its just a reuse of notation because in one specific circumstance it is proper time

The schwarzschild metric is an abstract object, which we can express in different coordinate systems. All of the above metrics describe the same fundamental object, but in different coordinates. These different coordinate systems may describe different parts of the spacetime, may have some special properties, or might be totally abstract - but there isn't a difference in what they represent

Different coordinate systems may have different properties. For example, schwarzschild coordinates - the one we used previously- has an artificial coordinate singularity at the event horizon, which makes it useless for what we're trying to do. #2 is schwarzschild in eddington-finkelstein coordinates, and is usable for describing geodesics which are travelling forwards in time into the black hole (or equivalently, geodesics that are travelling out of the black hole backwards in time). Because of the simplicity - we're going to use eddington finkelstein coordinates in the beginning

# Tetrads

Back in ye olde schwarzschild in schwarzschild coordinates days, we learnt briefly about the role of tetrads, as objects that can be used to take a local quantity, and transform into a quantity in our coordinate system (and vice versa). These objects also fundamentally relate the viewpoints of two different observers, and the first thing we need to learn is how to calculate and manipulate them. We're going to take a second crack at them now

As we've run into before: spacetime is locally flat. The technical definition of locally flat is the minkowski metric tensor $\eta_{\mu\nu}$: this is a diagonal matrix, that looks like this:

| |t|x|y|z|
|-|-|-|-|-|
|t|-1| | | |
|x| |1| | |
|y| | |1| |
|z| | | |1|

What we'd like to do, is define how to translate from our metric tensor $g_{\mu\nu}$, to our diagonal matrix $\eta_{\mu\nu}$ -we know from general relativity that the metric must be diagonalisable to produce the minkowski metric (as space is locally flat)

This is done via the standard relation:

$$D = P^{-1} A P$$

Where $D$ is our diagonal matrix, $A$ is our matrix to diagonalise, and $P$ is the diagonalising matrix. Put in our terminology[^wheresthet]

$$\eta = e^{T} g e$$

[^wheresthet]: Because the metric tensor is symmetric, the $^{-1}$ becomes a $^T$

The matrix $e$, treated as column vectors, makes up our tetrad vectors. On top of this, we can solve for $e$ and get 'a' valid set of tetrad vectors for any metric tensor, by solving this equation. Tetrads are not unique, so we're just solving for the view for some arbitrary observer, that's dependent on the specific form of the metric

Solving this is an eigenvalue problem, as $e$ also makes up the eigenvectors of the metric (and technically, $\eta_{\mu\nu}$ is the eigenvalues)

One important thing to get back to. Remember that vectors can be timelike ($ds^2 < 0$), or spacelike ($ds^2 > 0$). We have one timelike tetrad vector: which is always $e_0$, and 3 spacelike tetrad vectors, which are $e_k$

# Relativistic gram-schmidt

The most straightforward algorithm for doing this is called gram-schmidt orthonormalisation, and with a minor extension we can use this for solving our GR eigenvalue problem. Gram-schmidt is an algorithm for taking a series of vectors and making them orthonormal to each other. Here we take a series of coordinate vectors, and make them orthonormal with respect to the metric tensor from each other

We're going to start off with the basic algorithm, and then we'll make it robust against the horrors of GR

Lets start off with our 4 coordinate directions, which we hope are linearly independent:

```c++
std::array<t4f, 4> vecs = { {1, 0, 0, 0},
                            {0, 1, 0, 0},
                            {0, 0, 1, 0},
                            {0, 0, 0, 1} };
```

Note that, taking the column vectors of the metric $g_{\mu\nu}$, and raising them with the metric tensor to get $v^k$ (contravariant), produces exactly the same vectors we're starting off with here

We have to pick a vector to start our orthonormalisation from, so we pick the first vector $v_0$ arbitrarily, and now start up our algorithm:

```c++
m44f metric = get_metric();
tetrads tet = gram_schmidt(vecs[0], vecs[1], vecs[2], vecs[3], metric);
```

Relativistic gram schmidt itself looks like this:

```c++
valuef dot(t4f u, t4f v, m44f m) {
    t4f lowered = m.lower(u);

    return dot(lowered, v);
}

t4f gram_project(t4f u, t4f v, m44f m) {
    valuef top = dot_metric(u, v, m);
    valuef bottom = dot_metric(u, u, m);

    return (top / bottom) * u;
}

t4f normalise(t4f in, m44f m)
{
    valuef d = dot_metric(in, in, m);

    return in / sqrt(fabs(d));
}

struct tetrad ]
    std::array<t4f, 4> tetrvads;
}

tetrad gram_schmidt(t4f v0, t4f v1, t4f v2, t4f v3, m44f m)
{
    float4 u0 = v0;

    float4 u1 = v1;
    u1 = u1 - gram_project(u0, u1, m);

    float4 u2 = v2;
    u2 = u2 - gram_project(u0, u2, m);
    u2 = u2 - gram_project(u1, u2, m);

    float4 u3 = v3;
    u3 = u3 - gram_project(u0, u3, m);
    u3 = u3 - gram_project(u1, u3, m);
    u3 = u3 - gram_project(u2, u3, m);

    u0 = normalise(u0, m);
    u1 = normalise(u1, m);
    u2 = normalise(u2, m);
    u3 = normalise(u3, m);

    return {u0, u1, u2, u3}
};
```

We now have our tetrads

### Of course, it isn't remotely that simple

There are a few assumptions that we've made here

1. That the first vector we picked doesn't have a length of 0, ie it isn't null ($ds^2 = 0$)

2. The first vector we picked is *timelike*. In general, we always demand that our first tetrad $e_0$ is a timelike vector, and there's no guarantee that $(1, 0, 0, 0)$ points in a timewards direction

### Selecting the first vector

```c++
std::array<t4f, 4> vecs = { {1, 0, 0, 0},
                            {0, 1, 0, 0},
                            {0, 0, 1, 0},
                            {0, 0, 0, 1} };

std::array<valuef, 4> lengths;

for(int i=0; i < 4; i++{
    lengths[i] = metric.dot(vecs[i], vecs[i]);
}

valuei first_nonzero_vector = 0;

valuei idx = declare_mut_e(valuei(0));

buffer<valuef> arr = declare_array_e(valuei(0), 4);

for_e(idx < 4, assign_b(idx, idx+1), [&] {

});

```