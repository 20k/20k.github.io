---
layout: post
title:  "Numerical Relativity 104: Simulating binary neutron star collisions (N body relativistic eularian hydrodynamics)"
date:   2026-02-02 12:33:23 +0000
categories: C++
---

Some things are easy. Some things are hard. Some things are neutron star collisions. Lets get into it

# What are we doing today?

Modelling and simulating neutron stars is a multi step process. Lets break this down into two phases, and then break them down further as we get there

1. Initial conditions
2. Evolution equations

## Initial conditions

This involves solving multiple things, in sequence

1. First we must constructed an isolated neutron star. This will be modelled as a self gravitating fluid in equilibrium. We'll be solving an equation known as the TOV equation, which will fully describe our star
2. Then, we must re-describe that same star as a spinning, moving star. This involves solving a set of initial conditions, based around that initial star model, hoping that it closely enough approximates a real spinning neutron star. Doing this is a generalisation of our black hole initial conditions

# What even is a neutron star anyway?

Neutron stars are one of the possible final resting states of a star, when they run out of fuel, and begin to collapse. There are three mainstream kinds of stellar remnants:

1. White dwarves, made up of ordinary matter. These are supported by electron degeneracy pressure
2. Neutron stars, when the intense gravity forces electrons and protons to merge, forming neutrons. These are supported by neutron degeneracy pressure
3. Black holes, when gravity overcomes everything and there's no return

Today we're going to be looking at #2, and we'll dabble in #3

# Modelling a neutron star

Fun fact: Nobody really knows how neutron stars are structured internally. There's a wide range of theories, and the radius of a neutron star is pretty unknown. Because of this, we have to pick a model: The simplest model of a neutron star is what is called a [polytrope](https://en.wikipedia.org/wiki/Polytrope). This links together the pressure, and the (rest) density, by prescribing a relationship between the two:

$$P = K \rho_0^\Gamma$$

Where $K$ is a proportionality constant, $\Gamma$ is the polytropic index, $\rho_0$ is the rest mass, and $P$ is the pressure. Please note that there are multiple definitions of this equation: if you see an $n$ its a different convention. If we pick values of $\Gamma$ and $K$, this ties together $p_0$ and $P$. At this point, all we need is a central rest mass density, $\rho_c$, and we have (in theory) completely determined the structure of our star

Unfortunately, there is no analytic solution to any of this, because that would simply be too easy

## A body in hydrodynamic equilibrium: Tolman-Oppenheimer-Volkoff (TOV)

The equation that governs a relativistic, spherically symmetric body in hydrostatic equilibrium is called the TOV equation. This is a set of two coupled partial differential equations, which we must solve simultaneously. They are fully described by one parameter, which is the central density: the rest density of matter, at the centre of your body. Additionally, we have to supply an equation of state - our polytropic equation - that links the density and pressure together

Wikipedia lists an unnecessarily complicated form of the equations, so [here's (17)](https://www.as.utexas.edu/astronomy/education/spring13/bromm/secure/TOC_Supplement.pdf) a nicer form (in units of $c=G=1$, schwarzschild coordinates):

$$\begin{align}
\frac{dm}{dr} &= 4 \pi r^2 \epsilon\\
\frac{dP}{dr} &= -(\epsilon + P)\frac{m + 4 \pi r^3 P}{r(r-2m)}
\end{align}$$

|Symbol|Meaning|
|-|-|
|$r$|The radius, which parameterises the integration|
|$m$|The mass at a radius of less than $r$. Corresponds to the ADM mass|
|$P$|Pressure at $r$|
|$\epsilon$| Total internal energy density at $r$. This isn't the energy density integrated, 'total' refers to a combination of different energies - but at a specific point|

This is one of the areas of the literature where the notation is, frankly, really bad. I have no idea why, but people re-use the same symbols for everything, and they are sometimes even redefined on the fly. Here's how to actually calculate everything, and how it all relates:

|Symbol|Name|Si Units|Geometric Units|Derivation from $P$|Derivation from $\rho_0$|
|-|-|-|-|-|-|
|$\rho_0$|Rest Mass Density|$\mathrm{kg}\; \mathrm{m}^{-3}$|$\mathrm{m}^{-2}$|$(\frac{P}{K})^{1/\Gamma}$|$\rho_0$|
|$\epsilon$|Total Energy Density|$\mathrm{kg}\; \mathrm{m}^{-1}\; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$(\frac{P}{K})^{1/\Gamma} + \frac{P}{\Gamma-1}$|$\rho_0 + K \frac{\rho_0^\Gamma}{\Gamma-1}$|
|$P$|Pressure|$\mathrm{kg}\;\mathrm{m}^{-1} \; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$P$|$K \rho_0^\Gamma$|
|$K$|Polytropic Constant (informal)|$\mathrm{kg}^{1-\Gamma} \; \mathrm{m}^{3\Gamma-1}\;\mathrm{s}^{-2}$|$\mathrm{m}^{2\Gamma-2}$|||

It is common to solve these equations in units of $c=G=M_\odot$, where $M_\odot$ is the mass of the sun. This is why I've provided all the units up above, and we're going go through [converting](https://www.seas.upenn.edu/~amyers/NaturalUnits.pdf) from SI units, to geometric units ($c=G=1$), to that new unit system ($c=G=M_\odot$). In general, you need to redefine mass to avoid your numbers blowing up too much

The procedure is as follows:

1. Convert your quantity into geometric units
2. Convert the mass of the sun, $1.988416 * 10^{30} \mathrm{kg}$, into meters, which is Todo:
3. Divide your quantity in $\mathrm{m}^n$ (eg $\mathrm{m}^2$) by $(Todo:)^n$

I'll be showing you the code for how to do this. One thing to note is that $K$ is frequently given in geometric units instead of physical units, so I'll flag up when the units are wonky

## Solving the TOV equations

These equations are extremely easy to solve, once you've got everything in the correct units. Firstly, you might notice that the equations are singular at $r=0$. We're going to instead start at $r=r_{min}=10^{-6}$

Then, we need initial values for our other variables, at $r=r_{min}$:

|Variable|Value|
|-|-|
|$M$| $\frac{4}{3} \pi r_{min}^3 \epsilon\;$ (the integral of $\frac{dm}{dr}$, with $\epsilon$ held constant) |
|$P$| $K \rho_c^\Gamma$ |

Once we've done this, lets integrate. This is done by spotting that these are simple first order in 'time' (where $dt=dr$) systems, and can be solved with euler integration

### Implementation

These equations are extremely fast to solve, so we're going for the most basic solution here. Here's how all the unit conversions work:

```c++
///https://www.seas.upenn.edu/~amyers/NaturalUnits.pdf
//https://nssdc.gsfc.nasa.gov/planetary/factsheet/sunfact.html
double geometric_to_msol(double meters, double m_exponent)
{
    double m_to_kg = 1.3466 * pow(10., 27.);
    double msol_kg = 1.988416 * pow(10., 30.);
    double msol_meters = msol_kg / m_to_kg;

    return meters / pow(msol_meters, m_exponent);
}

double msol_to_geometric(double distance, double m_exponent)
{
    return geometric_to_msol(distance, -m_exponent);
}

double si_to_geometric(double quantity, double kg_exponent, double s_exponent)
{
    double G = 6.6743015 * pow(10., -11.);
    double C = 299792458;

    double factor = std::pow(G, -kg_exponent) * std::pow(C, 2 * kg_exponent - s_exponent);

    return quantity / factor;
}

double geometric_to_si(double quantity, double kg_exponent, double s_exponent)
{
    return si_to_geometric(quantity, -kg_exponent, -s_exponent);
}
```

The conversions between different quantities generally require $K$ and $\Gamma$, so I've implemented these all in a `parameters` struct for simplicity:

```c++

///https://colab.research.google.com/drive/1yMD2j3Y6TcsykCI59YWiW9WAMW-SPf12#scrollTo=6vWjt7CWaVyV
///https://www.as.utexas.edu/astronomy/education/spring13/bromm/secure/TOC_Supplement.pdf
///https://arxiv.org/pdf/gr-qc/0403029
struct parameters
{
    double K = 0;
    double Gamma = 0;

    ///p0 -> p
    ///equation of state
    double rest_mass_density_to_pressure(double rest_mass_density) const
    {
        return K * pow(rest_mass_density, Gamma);
    }

    double rest_mass_density_to_energy_density(double rest_mass_density) const
    {
        double p = rest_mass_density_to_pressure(rest_mass_density);

        double p0 = rest_mass_density;

        return p0 + p/(Gamma-1);
    }

    ///inverse equation of state
    ///p -> p0
    double pressure_to_rest_mass_density(double p) const
    {
        return std::pow(p/K, 1/Gamma);
    }

    double pressure_to_energy_density(double p) const
    {
        return pressure_to_rest_mass_density(p) + p / (Gamma - 1);
    }
};
```

Initialising our state, with our initial conditions in units of $c=G=M\odot$ is extremely straightforward as well:

```c++
struct integration_state
{
    double m = 0;
    double p = 0;
};

integration_state make_integration_state(double p0, double rmin, const parameters& param)
{
    double e = param.rest_mass_density_to_energy_density(p0);
    double m = (4./3.) * M_PI * e * pow(rmin, 3.);

    integration_state out;
    out.p = param.rest_mass_density_to_pressure(p0);
    out.m = m;
    return out;
}
```

Or, if you want to use SI units for the central density:

```c++
//p0 in si units
integration_state make_integration_state_si(double p0, double rmin, const parameters& param)
{
    //kg/m^3 -> m/m^3 -> 1/m^2
    double p0_geom = si_to_geometric(p0, 1, 0);
    //m^-2 -> msol^-2
    double p0_msol = geometric_to_msol(p0_geom, -2);

    return make_integration_state(p0_msol, rmin, param);
}
```

The actual integration itself is massively straightforward. While we could go much more complicated with the integrator, these equations appear to be fairly numerically stable and are super cheap to evaluate, so I'm just going route one:

```c++
struct integration_dr
{
    double dm = 0;
    double dp = 0;
};

integration_dr get_derivs(double r, const integration_state& st, const parameters& param)
{
    double e = param.pressure_to_energy_density(st.p);

    double p = st.p;
    double m = st.m;

    integration_dr out;

    out.dm = 4 * M_PI * e * pow(r, 2.);
    out.dp = -(e + p) * (m + 4 * M_PI * r*r*r * p) / (r * (r - 2 * m));
    return out;
}

struct integration_solution
{
    //in msols
    double M = 0;
    //in meters
    double R = 0;

    std::vector<double> pressure;
    std::vector<double> mass;
    std::vector<double> radius;
};

///units are c=g=msol
///i think i can just convert msol into natural units, and redefine length
integration_solution solve_tov(const integration_state& start, const parameters& param, double min_radius, double min_pressure)
{
    integration_state st = start;

    double current_r = min_radius;
    double dr = 1. / 1024.;

    integration_solution sol;

    double last_r = 0;
    double last_m = 0;

    while(1)
    {
        sol.pressure.push_back(st.p);
        sol.mass.push_back(st.m);

        double r = current_r;

        sol.radius.push_back(r);

        last_r = r;
        last_m = st.m;

        integration_dr data = get_derivs(r, st, param);

        st.m += data.dm * dr;
        st.p += data.dp * dr;
        current_r += dr;

        if(st.p < min_pressure)
            break;
    }

    sol.R = msol_to_geometric(last_r, 1);
    sol.M = last_m;

    return sol;
}
```

### Testing the implementation

Lets check out section [VII](https://arxiv.org/pdf/1606.04881) of this paper, which we're about to get *very* familiar with

|Parameter|Value|
|-|-|
|$\rho_c$|$\rho_c = 6.235\; 10^{17}\; \mathrm{kg}\;\mathrm{m}^{-3}$|
|$K$|$123.641 M_{\odot}^2$ in **geometric** units[^waste]|
|$\Gamma$|$2$|

[^waste]: If you'd like a peek behind the scenes on the development of these articles, it took me several days and 1k+ lines of code to figure out that this was the error that was preventing my integrator from working properly

Ideally, we'll simply have $M = 1.543 M_\odot$ and $R=13.4 \mathrm{km}$ pop out the other end

```c++
void solve()
{
    //kg/m^3
    double paper_p0 = 6.235 * pow(10., 17.);

    parameters param;
    param.K = 123.641;
    param.Gamma = 2;

    double rmin = 1e-6;

    integration_state st = make_integration_state_si(paper_p0, rmin, param);

    integration_solution sol = solve_tov(st, param, 1e-6, 0);

    std::cout << "Solved for " << sol.R / 1000. << "km " << sol.M << " msols " << std::endl;
}
```

We get this: `15.8102km 1.54315 msols`. Now, our mass is absolutely spot on, which is great, but it looks like the radius is wrong. This is slightly puzzling

Interestingly, a separate test case [here](https://colab.research.google.com/drive/1yMD2j3Y6TcsykCI59YWiW9WAMW-SPf12#scrollTo=00FWl5YzbSaB) actually gives the wrong answer, because their value of $N$ is too low. Increasing it, we're able to match their results for $\rho_c = 1.28 * 10^{-3}$ and $K=100$ in units of $c=G=M_{\odot}=1$, giving:

`14.1461km 1.40021msols`, which is extremely close. That code gives `14.136399564110704 1.400270088513766` with better precision, which is pretty close

TODO: IM PRETTY SURE ITS THE ISOTROPIC COORDINATES YA EEJIT

Its unclear exactly what's going on here. Given that we have exactly the correct mass, but a wrong radius: a few things could be happening, eg they may be using a more conservative definition of radius, or their solver may default to adding a crust. It would sure be helpful if there was a link to the code somewhere. it seems unlikely that we're completely wrong (that mass isn't an accident), so we're going to carry on for the moment

## Solving for a specific ADM mass

You might notice, the ADM mass is not our free parameter - despite generally being what we want to specify - but instead the central density is

I think we both know deep down in our hearts that this section wasn't going to read "here's how to calculate the central density from the ADM mass", and that instead we'd be forced to bruteforce it. Firstly, we can pick an initial guess for the central energy as follows:

$$M = \frac{4}{3} \pi r^3 \epsilon$$

Ie, we assume a constant $\epsilon$ through the star, then calculate this as a density. We'll have to guess our neutron star mass as well: the ratio of mass to radius is called the compactness factor $C$, and we can do $R=\frac{M}{C=0.06}$ as a guess. We're just looking for a vague ballpacrk range here

From there, you can simply bruteforce over a range of central density values, eg $\frac{\epsilon}{100}$ -> $5 \epsilon$, converted to rest densities

There's a teeny problem here. Neutron star ADM masses are not unique. You see, the graph of radius vs mass looks like this:

![neutron](/assets/nr4_neutron.PNG)

This means that there might be multiple solutions for central density for a specific ADM mass, and for realistic neutron stars there are at least two. Which makes this problem much more annoying. Anyway, lets write a basic procedure for this:

```c++

std::vector<double> search_for_adm_mass(double adm_mass, const parameters& param)
{
    double r_approx = adm_mass / 0.06;

    double start_E = adm_mass / ((4./3.) * M_PI * r_approx*r_approx*r_approx);
    double start_P = param.energy_density_to_pressure(start_E);
    double start_density = param.pressure_to_rest_mass_density(start_P);

    double rmin = 1e-6;

    std::vector<double> densities;
    std::vector<double> masses;

    int to_check = 2000;
    densities.resize(to_check);
    masses.resize(to_check);

    double min_density = start_density / 100;
    double max_density = start_density * 5;

    for(int i=0; i < to_check; i++)
    {
        double frac = (double)i / to_check;

        double test_density = mix(min_density, max_density, frac);

        integration_state next_st = make_integration_state(test_density, rmin, param);
        integration_solution next_sol = solve_tov(next_st, param, rmin, 0.);

        densities[i] = test_density;
        masses[i] = next_sol.M;
    }

    std::vector<double> out;

    for(int i=0; i < to_check - 1; i++)
    {
        double current = masses[i];
        double next = masses[i+1];

        double min_mass = std::min(current, next);
        double max_mass = std::max(current, next);

        if(adm_mass >= min_mass && adm_mass < max_mass)
        {
            double frac = (adm_mass - min_mass) / (max_mass - min_mass);

            out.push_back(mix(densities[i], densities[i+1], frac));
        }
    }

    return out;
}
```

This performs a pretty basic bruteforce through the parameter space, and looks for mass crossings which match our result. Something smarter would refine the result more closely instead of linearly bruteforcing, but it works fine. The lower density branch here (with larger radius) is the correct neutron star in our case, which we simply have to know a-priori

## Key takeaways from solving TOV

At the end of this process, we've gained the ability to describe the following variables of our neutron star: rest mass density $\rho_0$, energy density $\epsilon$, ADM mass $M$, and pressure $P$. Keep this in mind as we carry on forwards. We've now solved the first step in our initial conditions procedure: constructing a static neutron star

Next up, we need to give it momentum and spin. This is where things get a bit complicated

# Bowen-York Type Initial Data for Binaries with Neutron Stars

The actual paper we're going to be implementing today is [this](https://arxiv.org/pdf/1606.04881) one. Its going to be a step up in complexity compared to things we've solved previously together. One of the key things today in this article is that I'm going to present you with a simpler and fast procedure for implementing this paper, without losing any generality, as I've been able to skip some of the complexity. For consistency, we'll be keeping our existing notation, and below is the conversions we'll make

Todo: Notational layout conversions

Todo: This is a table now. Note that this paper defines $\rho$ as what we've been calling $\epsilon$, and it calls $\epsilon$ a separate quantity we don't have (specific internal energy density). I'm going to keep our existing notation, and translate where appropriate, to try and stem the incredibly random notation

If you remember from our black hole initial conditions paper, the basic idea for many kinds of initial conditions is that of conformal flatness. That is to say, we take our adm metric $\gamma_{ij}$, and perform a conformal transform on it by a scalar, to end up with a conformal metric. In this paper, our ADM variables are transformed as follows:

$$\begin{align}
\gamma_{ij} &= \Phi^4 \bar{\gamma}_{ij}\\
A_{ij} &= \Phi^{-2} \bar{A}_{ij}
\end{align}$$

Where $$\bar{\gamma}_{ij}$$ is the conformally flat (ie the identity matrix) metric tensor, $A_{ij}$ is the extrinsic curvature, and $\Phi$ is the conformal factor. Its important to note that this is the same conformal decomposition as the black hole initial conditions we've used previously[^explicitly]. Similarly, we're trying to solve for exactly two things only in this paper

1. The conformal factor $\Phi$
2. The extrinsic curvature $$\bar{A}_{ij}$$

[^explicitly]: I explicitly picked this paper because it allows us to construct multiple black holes and neutron stars together

The conformally flatness assumption, as well as the maximal slice assumption, gives us a familiar looking constraint to solve:

$$\partial^i \partial_i \Phi = -\frac{1}{8} \Phi^{-7} \bar{A}_{ij} \bar{A}^{ij} - 2 \pi \Phi^5 \epsilon_H$$

One thing to note is that any time you see a $\pi$, its a sure fire bet that it means there are matter terms involved

|Variable|Meaning|
|-|-|
|$\Phi$|Conformal factor, unknown|
|$\bar{A}_{ij}$| Conformal extrinsic curvature|
|$\epsilon_H$| TODO: I DONT HAVE A CLUE|

This paper in theory lets us solve the TOV equations in a conformally flat spacetime, via (77-79), but we've deliberately skipping this step, as solving the TOV equations directly is much simpler. In general I wouldn't recommend implementing section VI (other than (83-84)), and I think eq (82) is incorrect unfortunately

## Implementing this paper

The procedure in this paper is as follows:

1. Solve for $\Phi_{tov}$, a conformal factor for the isotropic TOV solution
2. Use that to calculate $\bar{A}_{ij}$
3. Use that $\bar{A}_{ij}$ solution to construct $\Phi$, the real conformal factor
4. Bob's your uncle

## Solving for $\Phi_{tov}$

First off, we need to start over in section VI. Given that we a-priori have our matter distribution, we don't need to solve for $\alpha$, or $\Theta$ luckily, and the only variable we need is $\Phi_{tov}$. The standard approach to solving for $\Phi_{tov}$ is either (86):

$$\Delta \Phi_{tov} = -2 \pi \Phi_{tov}^5 \epsilon_{tov}$$

Or we could also solve the 1d equation (77):

$$\frac{1}{\bar{r}^2}\frac{d(\bar{r}^2 \frac{d\Phi_{tov}}{d\bar{r}})}{d\bar{r}} = -2 \pi \Phi_{tov}^5 \epsilon_{tov}$$

Which is more usefully expressed as:

$$\bar{r}\frac{d^2\Phi_{tov}}{d\bar{r}^2} + 2 \frac{d\Phi_{tov}}{d\bar{r}} + 2 \pi \bar{r} \Phi_{tov}^5 \epsilon_{tov} = 0$$

There's a nicer way of solving for $\Phi_{tov}$, but first we should talk about $\bar{r}$. One thing that absolutely must be noted is that the paper we're working on is in *isotropic* coordinates with the radial coordinate $\bar{r}$. Up until now, we've been working in *schwarzschild* coordinates with the radial coordinate $r$. We're going to have to perform a conversion between the two. It isn't too complicated: the conversion function is defined [as follows (15)](https://einsteintoolkit.org/thornguide/EinsteinInitialData/TOVSolver/documentation.html#x1-2004r4):

$$\frac{d(\log(\frac{\bar{r}}{r}))}{\partial r} = \frac{r^{\frac{1}{2}} - (r - 2m)^\frac{1}{2}}{r(r - 2m)\frac{1}{2}}$$

Integrating this is straightforward, and can be done with an euler technique. $m(r)$ is still the cumulative mass from earlier. To get back to the topic at hand, note that we're looking for a $\Phi_{tov}$ from a metric defined as follows:

$$ds^2 = -\alpha^2(\bar{r}) dt^2 + (\Phi_{tov}(\bar{r}))^4(d\bar{r}^2 + \bar{r}^2 d\Omega)$$

The einstein toolkit page lists TOV in isotropic coordinates as:

$$ds^2 = -e^{2\phi} dt^2 +e^{2\Lambda}(d\bar{r}^2 + \bar{r}^2 d\Omega^2)$$

We can see that $e^{2\Lambda} = \Phi_{tov}^4$. And, helpfully, someone smarter[^smrt] than I am has worked out that $e^{\Lambda} = \frac{r}{\bar{r}}$

[^smrt]: [https://physics.stackexchange.com/questions/145342/schwarzschild-metric-in-isotropic-coordinates](https://physics.stackexchange.com/questions/145342/schwarzschild-metric-in-isotropic-coordinates)

This is a much nicer way of calculating this, as $\Phi_{tov} = (\frac{r}{\bar{r}})^\frac{1}{2}$. No laplacians required. We'll also have to note: in the future, if we take the pressure at a radius, we'll need to perform a coordinate conversion if that radius is in isotropic coordinates: ie we need to keep on hand the function $r = f(\bar{r})$, which you should tabulate somewhere

Todo: Matching parameters to star exterior

## Calculating $\bar{A}^{ij}$

Next up: The extrinsic curvature. First off, we calculate (83-84), remembering that we're using slightly different notation from this paper:

$$\begin{align}
\bar{\epsilon} &= \Phi_{tov}^8 \epsilon_{tov}\\
\bar{p} &= \Phi_{tov}^8 p_{tov}
\end{align}$$

From here, its time to dig into the really fun bits. As with our black hole solution, we have two parameters we can specify: the ADM momentum $P^i$, and the angular momentum $J^i$. These are broken up into two equations: (51), and (54) - which we simply sum together

### $P^i$ (linear momentum)

To calculate the contribution from the linear momentum, we need to calculate this equation:

$$\begin{align}
\bar{A}^{ij}_P &=\frac{3Q}{2r^2}(P^i l^j + P^j l^i - (\eta^{ij} - l^i l^j)(P^k l_k)) \\
&+ \frac{3C}{r^4} (P^i l^j + P^j l^i + (\eta^{ij} - 5l^i l^j)(P^k l_k))\\
\end{align}
$$

Here's what everything means

|Symbol|Definition|
|-|-|
|$P^i$|ADM linear momentum|
|$r$|Coordinate distance (in isotropic coordinates) from the neutron star's origin|
|$\eta^{ij}$| The inverse of the conformally flat metric tensor (here: the identity matrix)|
|$l^i$| $l^i=\frac{x^i}{r}$, a unit radial vector|
|$Q$ and $C$| We'll get to these|

The quantities here are trivial to calculate, except for $Q$ and $C$. This is where the information in this paper gets a bit.. scattered, so I'm simply going to present the order of things to calculate

From now on, **our $r$ coordinate is always isotropic**. You should either re-layout your quantities from schwarzschild to isotropic, or dynamically convert the coordinate to schwarzschild and look them up

#### $\mathcal{M}$

The first thing we need is to calculate $\mathcal{M}$. This is straightforward via (59)

$$\mathcal{M} = 4\pi \int^{r_0}_0 (\bar{\epsilon} + \bar{p}) r^2 dr$$

Integrating this is a straightforward piecewise numerical integration. $r_0$ is the isotropic radius of our neutron star. Note that this quantity is not the same as $M$

#### $\sigma$

Next up, we'll calculate sigma. This is straightforwardly done via (57):

$$\sigma = \frac{\bar{\epsilon} + \bar{p}}{\mathcal{M}}$$

#### $Q$ and $C$

These functions are both functions of the radius. To emphasise this, I'll specify them as follows:

$$\begin{align}
Q(r) &= 4 \pi \int^r_0 \sigma x^2\; dx\\
C(r) &= \frac{2}{3} \pi \int^r_0 \sigma x^4\; dx\\
\end{align}
$$

When $r > r_0$, $Q(r)=1$, and you should enforce this. The paper does not specify a value for $C(r)$ where $r > r_0$, so I set $C(r) = C(r_0)$ in this region

I personally found the $r'$ notation to be pretty confusing given that its also used for differentiation when I first read this paper, so I've swapped the notation to make it clearer that it is an integration variable. Note that $\sigma$ is also a function, so here we'd be doing $\sigma(x)$

### $J^i$ (angular momentum)

The equation for this is (54):

$$\bar{A}^{ij}_J =\frac{6}{r^3}l^{(i} \epsilon^{{j)}kl}J_k l_l N$$

Here's what everything means

|Symbol|Definition|
|-|-|
|$J^i$|ADM angular momentum (lower with $\eta_{ij}$, here the identity matrix)|
|$r$|Coordinate distance (in isotropic coordinates) from the neutron stars origin|
|$l^i$| $l^i=\frac{x^i}{r}$, a unit radial vector (lower with $\eta_{ij}$)|
|$N$| We'll get to this|

As previously, we'll dig into the procedure for calculating $N$, and linearise the procedure because the functions are a bit scattered

#### $\mathcal{N}$

You might be wondering if having two functions named $\mathcal{N}$ and $N$ might have resulted in days of confusion for a poor lost developer several years ago, who was reading this as an early paper in their NR journey when they didn't know any better than to be hypervigilant of notational issues

Implementing this is under (64):

$$\mathcal{N} = \frac{8 \pi}{3} = \int^{r_0}_0 (\bar{\epsilon} + \bar{p}) r^4\; dr$$

Where $r_0$ is the isotropic radius of our neutron star, and $r$ is the integration variable. Perhaps this goes without saying for people with better reading skills than me, but this function is **not** $N$ >:|

#### $\kappa$

(62)

$$\kappa =\frac{\bar{\epsilon} + \bar{p}}{\mathcal{N}}$$

#### N

(55)

$$N(r) = \frac{8 \pi}{3} \int^r_0 \kappa x^4 dx$$

Remembering that $\kappa(x)$ is a function, and $x$ is the integration variable

When $r>r_0$, $N(r) = 1$, and you should enforce this

## Calculating $\Phi$, the conformal factor

We now have $\bar{\epsilon}$, $\bar{p}$, and $\bar{A}^{ij} = \bar{A}^{ij}_P + \bar{A}^{ij}_J$. We're going to put this all together, and solve the final piece of our puzzle (22):

$$\Delta \Phi = -\frac{1}{8} \Phi^{-7} \bar{A}_{ij} \bar{A}^{ij} - 2 \pi \Phi^{-3} \bar{\epsilon}_H$$

This is a standard laplacian. We're going to go over the details of how to perform our full construction after we finish up our next step, which is solving for $\epsilon_H$. It can't be too bad right?

### Solving for $\epsilon_H$ was indeed that bad

The definition can be found by applying $\Phi_{tov}^8$ to $\epsilon_H$ (6 + 20):

$$\bar{\epsilon}_H = (\bar{\epsilon} + \bar{p})W^2 - \bar{p}$$

Which should be set to $0$ when $r>r_0$. What's $W$?

#### $W$, aka the lorentz factor

There are two lorentz factors in this paper. One for the linear momentum, and one for the angular momentum

Linear (60):

$$W_{P}^2 = \frac{1}{2}(1 + \sqrt{1 + \frac{4 P_i P^i}{\mathcal{M}^2}})$$

Angular (65):

$$\begin{align}
W_{J}^2 &=\frac{1}{2}(1 + \sqrt{1 + \frac{4 J_i J^i r^2 \sin^2 \theta}{\mathcal{N}^2}})\\
\sin^2 \theta &= 1 - (J^i l_i)^2 \\
\end{align}$$

$l_i$ is the same unit normal as earlier. For $\sin^2 \theta$, you'll want to ensure that $J^i$ and $l_i$ are normalised to a length of $1$, as we're using the formula $\mathrm{dot}(a, b) = \cos \theta ||a||\;||b||$

Sometimes I wish I'd taken up fishing

#### Combining lorentz factors

Of course, we can't simply *add* lorentz factors together, that'd be madness. Instead we have to use the rapidity formula. This gives us:

$$W = \mathrm{cosh}(\mathrm{arccosh}(W_P) + \mathrm{arccosh}(W_J)) $$

With this done, its finally over, and I can now describe the procedure for solving our laplacian

### Solving the laplacian, finally


# This article, abridged

## Step 1

Solve these two equations for the following quantities: mass ($M$), radius ($R$), and energy density ($\epsilon$). Stop integrating when $P <= 0$. This determines $R$. The integration should start at $r=r_{min}$

$$\begin{align}
\frac{dm}{dr} &= 4 \pi r^2 \epsilon\\
\frac{dP}{dr} &= -(\epsilon + P)\frac{m + 4 \pi r^3 P}{r(r-2m)}
\end{align}$$

With the relation:

$$P = K \rho_0^\Gamma$$

Boundary conditions are:

1. $M(0) = \frac{4}{3} \pi r_{min}^3 \epsilon_0$,
2. $P(0) = K \rho_{c}^\Gamma$, where $\rho_{c}$ is the central rest mass density

Todo: List $\epsilon$

## Step 2


## papers

Analytic: https://www.aanda.org/articles/aa/pdf/2010/06/aa12738-09.pdf

Numerical: https://arxiv.org/pdf/1606.04881

Useful ref: https://arxiv.org/pdf/gr-qc/0403029

Today

## Approximating TOV

For $\Gamma=2$, there are approximations that can be used from eg [here (page 3)](https://www.aanda.org/articles/aa/pdf/2010/06/aa12738-09.pdf). I actually used this one for a while, and would highly recommend it if you don't want to solve TOV yourself

## I think there's an error in one of the equations

I'm 80% sure that (82) is incorrect, and that the leading factor of $2 \pi$ should be $4 \pi$. It gives exactly half the expected ADM mass for me