---
layout: post
title:  "Numerical Relativity 104: Simulating binary neutron star collisions (N body relativistic eularian hydrodynamics)"
date:   2026-02-02 12:33:23 +0000
categories: C++
---

Some things are easy. Some things are hard. Some things are neutron star collisions. Lets get into it

# What even is a neutron star anyway?

Neutron stars are one of the possible final resting states of a star, when they run out of fuel, and begin to collapse. There are three mainstream kinds of stellar remnants:

1. White dwarves, made up of ordinary matter. These are supported by electron degeneracy pressure
2. Neutron stars, when the intense gravity forces electrons and protons to merge, forming neutrons. These are supported by neutron degeneracy pressure
3. Black holes, when gravity overcomes everything and there's no return

Today we're going to be looking at #2, and we'll dabble in #3

# Modelling a neutron star

Fun fact: Nobody really knows what neutron stars are made up of internally. There's a wide range of theories, and the radius of a neutron star is pretty unknown. Because of this, we have to pick a model: The simplest model of a neutron star is what is called a [polytrope](https://en.wikipedia.org/wiki/Polytrope). This links together the pressure, and the (rest) density, by prescribing a relationship between the two:

$$P = K \rho_0^\Gamma$$

Where $K$ is a proportionality constant, $\Gamma$ is the polytropic index, $\rho_0$ is the rest mass, and $P$ is the pressure. Please note that there are multiple definitions of this equation: if you see an $n$ its a different convention. If we pick values of $\Gamma$ and $K$, this ties together $p_0$ and $P$. At this point, all we need is a central rest mass density, $\rho_c$, and we have (in theory) completely determined the structure of our star

Unfortunately, there is no analytic solution to any of this, because that would simply be too easy. So lets dig into some numerics:

## A body in hydrodynamic equilibrium: Tolman-Oppenheimer-Volkoff (TOV)

The equation that governs a relativistic, spherically symmetric body in hydrostatic equilibrium is called the TOV equation. This is a set of two coupled partial differential equations, which we must solve simultaneously. They only have one parameter, which is the central density: the rest density of matter, at the centre

. Wikipedia lists an unnecessarily complicated form of the equations, so [here's (17)](https://www.as.utexas.edu/astronomy/education/spring13/bromm/secure/TOC_Supplement.pdf) a nicer form (in units of $c=G=1$):

$$\begin{align}
\frac{dm}{dr} &= 4 \pi r^2 \epsilon\\
\frac{dP}{dr} &= -(\epsilon + P)\frac{m + 4 \pi r^3 P}{r(r-2m)}
\end{align}$$

|Symbol|Meaning|
|-|-|
|$r$|The radius, which parameterises the integration|
|$m$|The mass at a radius of less than $r$. Corresponds to the ADM mass|
|$P$|Pressure at $r$|
|$\epsilon$| Total internal energy density at $r$. This isn't the energy density integrated, 'total' refers to a combination of different energies - but at a specific point|

This is one of the areas of the literature where the notation is, frankly, really bad. I have no idea why, but people re-use the same symbols for everything, and they are sometimes even redefined on the fly. Here's how to actually calculate everything, and how it all relates:

|Symbol|Name|Si Units|Geometric Units|Derivation from $P$|Derivation from $\rho_0$|
|-|-|-|-|-|-|
|$\rho_0$|Rest Mass Density|$\mathrm{kg}\; \mathrm{m}^{-3}$|$\mathrm{m}^{-2}$|$(\frac{P}{K})^{1/\Gamma}$|$\rho_0$|
|$\epsilon$|Total Energy Density|$\mathrm{kg}\; \mathrm{m}^{-1}\; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$(\frac{P}{K})^{1/\Gamma} + \frac{P}{\Gamma-1}$|$\rho_0 + K \frac{\rho_0^\Gamma}{\Gamma-1}$|
|$P$|Pressure|$\mathrm{kg}\;\mathrm{m}^{-1} \; \mathrm{s}^{-2}$|$\mathrm{m}^{-2}$|$P$|$K \rho_0^\Gamma$|
|$K$|Polytropic Constant (informal)|$\mathrm{kg}^{1-\Gamma} \; \mathrm{m}^{3\Gamma-1}\;\mathrm{s}^{-2}$|$\mathrm{m}^{2\Gamma-2}$|||

It is common to solve these equations in units of $c=G=M_\odot$, where $M_\odot$ is the mass of the sun. This is why I've provided all the units up above, and we're going go through [converting](https://www.seas.upenn.edu/~amyers/NaturalUnits.pdf) from SI units, to geometric units ($c=G=1$), to that new unit system ($c=G=M_\odot$). In general, you need to redefine mass to avoid your numbers blowing up too much

To get an idea of how it works, first notice that we can convert the mass of the sun from kilograms, to meters. Then, we can change our scale, such that the mass of the sun is $1$, in units of new distance. Unit conversions proceed as you'd expect then, giving the following procedure:

1. Convert your quantity into geometric units
2. Convert the mass of the sun, $1.988416 * 10^{30} \mathrm{kg}$, into meters, which is Todo:
3. Divide your quantity in $\mathrm{m}^n$ (eg $\mathrm{m}^2$) by $(Todo:)^n$

I'll be showing you the code for how to do this. One thing to note is that $K$ is frequently given in geometric units instead of physical units, so I'll flag up when the units are wonky

## Solving the TOV equations

These equations are extremely easy to solve, once you've got everything in the correct units. Firstly, you might notice that the equations are singular at $r=0$. We're going to instead start at $r=r_{min}=10^{-6}$

Then, we need initial values for our other variables, at $r=r_{min}$:

|Variable|Value|
|-|-|
|$M$| $\frac{4}{3} \pi r_{min}^3 \epsilon$ |
|$P$| $K \rho_c^\Gamma$ |

Once we've done this, lets integrate. This is done by spotting that these are simple first order in 'time' (where $dt=dr$) systems, and can be solved with euler integration

### Implementation

These equations are extremely fast to solve, so we're going for the most basic solution here. Here's how all the unit conversions work:

```c++
///https://www.seas.upenn.edu/~amyers/NaturalUnits.pdf
//https://nssdc.gsfc.nasa.gov/planetary/factsheet/sunfact.html
double geometric_to_msol(double meters, double m_exponent)
{
    double m_to_kg = 1.3466 * pow(10., 27.);
    double msol_kg = 1.988416 * pow(10., 30.);
    double msol_meters = msol_kg / m_to_kg;

    return meters / pow(msol_meters, m_exponent);
}

double msol_to_geometric(double distance, double m_exponent)
{
    return geometric_to_msol(distance, -m_exponent);
}

double si_to_geometric(double quantity, double kg_exponent, double s_exponent)
{
    double G = 6.6743015 * pow(10., -11.);
    double C = 299792458;

    double factor = std::pow(G, -kg_exponent) * std::pow(C, 2 * kg_exponent - s_exponent);

    return quantity / factor;
}

double geometric_to_si(double quantity, double kg_exponent, double s_exponent)
{
    return si_to_geometric(quantity, -kg_exponent, -s_exponent);
}
```

The conversions between different quantities generally require $K$ and $\Gamma$, so I've implemented these all in a `parameters` struct for simplicity:

```c++

///https://colab.research.google.com/drive/1yMD2j3Y6TcsykCI59YWiW9WAMW-SPf12#scrollTo=6vWjt7CWaVyV
///https://www.as.utexas.edu/astronomy/education/spring13/bromm/secure/TOC_Supplement.pdf
///https://arxiv.org/pdf/gr-qc/0403029
struct parameters
{
    double K = 0;
    double Gamma = 0;

    ///p0 -> p
    ///equation of state
    double rest_mass_density_to_pressure(double rest_mass_density) const
    {
        return K * pow(rest_mass_density, Gamma);
    }

    double rest_mass_density_to_energy_density(double rest_mass_density) const
    {
        double p = rest_mass_density_to_pressure(rest_mass_density);

        double p0 = rest_mass_density;

        return p0 + p/(Gamma-1);
    }

    ///inverse equation of state
    ///p -> p0
    double pressure_to_rest_mass_density(double p) const
    {
        return std::pow(p/K, 1/Gamma);
    }

    double pressure_to_energy_density(double p) const
    {
        return pressure_to_rest_mass_density(p) + p / (Gamma - 1);
    }
};
```

Initialising our state, with our initial conditions in units of $c=G=M\odot$ is extremely straightforward as well:

```c++
struct integration_state
{
    double m = 0;
    double p = 0;
};

integration_state make_integration_state(double p0, double rmin, const parameters& param)
{
    double e = param.rest_mass_density_to_energy_density(p0);
    double m = (4./3.) * M_PI * e * pow(rmin, 3.);

    integration_state out;
    out.p = param.rest_mass_density_to_pressure(p0);
    out.m = m;
    return out;
}
```

Or, if you want to use SI units for the central density:

```c++
//p0 in si units
integration_state make_integration_state_si(double p0, double rmin, const parameters& param)
{
    //kg/m^3 -> m/m^3 -> 1/m^2
    double p0_geom = si_to_geometric(p0, 1, 0);
    //m^-2 -> msol^-2
    double p0_msol = geometric_to_msol(p0_geom, -2);

    return make_integration_state(p0_msol, rmin, param);
}
```

The actual integration itself is massively straightforward. While we could go much more complicated with the integrator, these equations appear to be fairly numerically stable and are super cheap to evaluate, so I'm just going route one:

```c++
struct integration_dr
{
    double dm = 0;
    double dp = 0;
};

integration_dr get_derivs(double r, const integration_state& st, const parameters& param)
{
    double e = param.pressure_to_energy_density(st.p);

    double p = st.p;
    double m = st.m;

    integration_dr out;

    out.dm = 4 * M_PI * e * pow(r, 2.);
    out.dp = -(e + p) * (m + 4 * M_PI * r*r*r * p) / (r * (r - 2 * m));
    return out;
}

struct integration_solution
{
    //in msols
    double M = 0;
    //in meters
    double R = 0;

    std::vector<double> pressure;
    std::vector<double> mass;
    std::vector<double> radius;
};

///units are c=g=msol
///i think i can just convert msol into natural units, and redefine length
integration_solution solve_tov(const integration_state& start, const parameters& param, double min_radius, double min_pressure)
{
    integration_state st = start;

    double current_r = min_radius;
    double dr = 1. / 1024.;

    integration_solution sol;

    double last_r = 0;
    double last_m = 0;

    while(1)
    {
        sol.pressure.push_back(st.p);
        sol.mass.push_back(st.m);

        double r = current_r;

        sol.radius.push_back(r);

        last_r = r;
        last_m = st.m;

        integration_dr data = get_derivs(r, st, param);

        st.m += data.dm * dr;
        st.p += data.dp * dr;
        current_r += dr;

        if(st.p < min_pressure)
            break;
    }

    sol.R = msol_to_geometric(last_r, 1);
    sol.M = last_m;

    return sol;
}
```

### Testing the implementation

Lets check out section [VII](https://arxiv.org/pdf/1606.04881) of this paper, which we're about to get *very* familiar with

|Parameter|Value|
|-|-|
|$\rho_c$|$\rho_c = 6.235\; 10^{17}\; \mathrm{kg}\;\mathrm{m}^{-3}$|
|$K$|$123.641 M_{\odot}^2$ in **geometric** units[^waste]|
|$\Gamma$|$2$|

[^waste]: If you'd like a peek behind the scenes on the development of these articles, it took me several days and 1k+ lines of code to figure out that this was the error that was preventing my integrator from working properly

Ideally, we'll simply have $M = 1.543 M_\odot$ and $R=13.4 \mathrm{km}$ pop out the other end

```c++
void solve()
{
    //kg/m^3
    double paper_p0 = 6.235 * pow(10., 17.);

    parameters param;
    param.K = 123.641;
    param.Gamma = 2;

    double rmin = 1e-6;

    integration_state st = make_integration_state_si(paper_p0, rmin, param);

    integration_solution sol = solve_tov(st, param, 1e-6, 0);

    std::cout << "Solved for " << sol.R / 1000. << "km " << sol.M << " msols " << std::endl;
}
```

Testing, we get blahblah link code

## Approximations

Todo:

For $\Gamma=2$, there are approximations that can be used from eg [here (page 3)](https://www.aanda.org/articles/aa/pdf/2010/06/aa12738-09.pdf)

## Bowen-York Type Initial Data for Binaries with Neutron Stars

The actual paper we're going to be implementing today is [this](https://arxiv.org/pdf/1606.04881) one. It is not the simplest paper in the whole universe. The actual information is also a bit scattered around in various places, so I'm going to dig into this in a kind of depth first fashion to explain to you the different bits of theory, and then we'll linearise our thinking at the end to provide a full end to end solution

If you remember from our black hole initial conditions paper, the basic idea for many kinds of initial conditions is that of conformal flatness. That is to say, we take our adm metric $\gamma_{ij}$, and perform a conformal transform on it by a scalar, to end up with a conformal metric. In this paper, our ADM variables are transformed as follows:

$$\begin{align}
\gamma_{ij} &= \Phi^4 \tilde{\gamma}_{ij}\\
A_{ij} &= \Phi^{-2} \tilde{A}_{ij}
\end{align}$$

Where $$\tilde{\gamma}_{ij}$$ is the conformally flat (ie the identity matrix) metric tensor, $A_{ij}$ is the extrinsic curvature, and $\Phi$ is the conformal factor. Its important to note that this is the same conformal decomposition as the black hole initial conditions we used previously[^explicitly]

[^explicitly]: I explicitly picked this paper because it allows us to construct multiple black holes and neutron stars together

The metric in this form is:

$$\partial^i \partial_i \Phi = -\frac{1}{8} \Phi^{-7} \bar{A}_{ij} \bar{A}^{ij} - 2 \pi \Phi^5 \rho_H$$

One thing to note is that any time you see a $pi$, its a sure fire bet that it means there are matter terms involved. This may look familiar from our black hole initial conditions

|Variable|Meaning|
|-|-|
|$\Phi$|Conformal factor, unknown|
|$\bar{A}_{ij}$| Conformal extrinsic curvature|
|$\rho_H$| TODO: I DONT HAVE A CLUE|

## papers

Analytic: https://www.aanda.org/articles/aa/pdf/2010/06/aa12738-09.pdf

Numerical: https://arxiv.org/pdf/1606.04881

Useful ref: https://arxiv.org/pdf/gr-qc/0403029

Today